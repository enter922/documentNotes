

## 事务

### **事务的特性ACID**

1. **A**tomicity  原子性 	 
   - 事务是一组最小的操作。不可再分，要么全部成功，要么全部失败。**通过undolog实现。**

2. **C**onsistency  一致性	  
   - 事务开启、提交、回滚前后数据都是一致的。**通过其他三个特性维持。**

3. **I**solation  隔离性
   - 数据库提供不同的事务隔离级别，保证不受外部事务并发影响。**通过加锁和MVCC实现。**

4. **D**urability  持久性
   - 事务一旦提交或回滚，对数据的影响是永久的。**通过redolog实现。**




### **并发事务带来的问题**

1. **脏读**
   - 一个事务读取到了未提交的数据
2. **不可重复读**
   -  在同一次事务中，先后读取的同一条数据不相同。即：A事务读取了B事务已经提交的更改数据
3. **幻读**
   - 在同一次事务中，由于其他事务的插入或删除，每一次读取到的数据不相同
   - 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在  

> 不可重复读和幻读都指的是：先后读取的数据不一致。不可重复读侧重于读取时，幻读侧重于修改时
>
> 可以使用不同的事务隔离级别来解决这些问题



### **事务隔离级别**

- 读未提交：
  - 可以读取其他事务未提交的数据，但不能修改其他事务正在修改的数据

  - 脏读、不可重复读和幻读

- 读提交：
  - 保证一个事务提交后才能被另外一个事务读取        能读取其他事务已提交的数据

  - 不可重复读和幻读

- 重复读：
  - InnoDB默认的级别，保证在同一个事务中多次读取同样的记录结果是一致的

  - 幻读

- 串行化 ：
  - 最高的隔离级别，添加表琐，强制事务串行执行
  - 无

> 事务隔离级别是针对于读的，通过MVCC控制隔离级别





## 事务汇总

| 名称   | 含义                           | 原理         |
| ------ | ------------------------------ | ------------ |
| 原子性 | 一组最小的操作，不可分割       | undoLog      |
| 一致   | 数据前后一致                   | 其他三大特性 |
| 隔离   | 不同的隔离级别，解决不同的问题 | MVCC+琐      |
| 持久   | 事务提交后，改变是永久的       | readLog      |

**并发事务问题**

| 问题       | 定义                             |
| ---------- | -------------------------------- |
| 脏读       | 读取到了其他事务未提交的事务     |
| 不可重复读 | 先后读取不一致，主要体现在新增上 |
| 幻读       | 先后读取不一致，主要体现在修改上 |

**隔离级别**

| 级别     | 可能的问题                            |
| -------- | ------------------------------------- |
| 读未提交 | 脏读  不可重复读（新增） 幻读（修改） |
| 读已提交 | 不可重复读 幻读                       |
| 可重复读 | 幻读，innoDB默认级别                  |
| 串行化   | 通过加锁，性能最低                    |

读未提交   脏读  不可重复读（新增） 幻读（修改）
读已提交   不可重复读 幻读
可重复读   幻读
串行化    



## 索引失效场景

**不满足最左前缀法则**

- 由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。


- 尽量使用最左前嘴法则来匹配数据

**使用`Or`右边字段没有索引，则左边失效** 

- 这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
- 可对右边字段添加索引，或尽量添加联合索引。

**使用左模糊匹配**

- 索引使用左模糊匹配或左右模糊匹配，索引将失效。因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。
- 尽量使用右模糊匹配。

**对索引使用函数计算**

- 因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。
- 不对索引使用函数计算。

**隐式类型转换**

- 如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话索引将失效


- 使用对应类型的数据输入。


**数据分布**

- InnoDB会评估索引之间的以及全表扫描的一个性能，在数据分布的影响下，innoDB评估全表扫描比索引快，则放弃索引。


- 如达不到预期可以使用SQL建议


> 索引失效场景原理多数和B+树顺序有关



## mysql三大日志

总所知周，事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？

- 事务的隔离性由锁机制实现。
- 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。
  - redo Log 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。
  - undo Log 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。

有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO 都可以视为是一种 恢复操作，但是：

- **redo log**: 是存储引擎层(innodb)成的日志，记录的是`物理级别`上的页修改操作。比如页号xxx、偏移量yyy写入了zzz数据。主要为了保证数据的可靠性;

- **undo log**: 是存储引擎层(innodb)生成的日志，记录的是 `逻辑操作`日志。比如对某一行数据进行了INSERT语句操作，那么 undo log就记录一条与之相反的delete操作。主要用于事务的回滚(undo log 记录的是每个修改操作的 逆操作)和 一致性非锁定读(undo og 回滚行记录到某种特定的版本--MVCC，即多版本并发控制)。

> 通常在一个事务中，涉及多个修改操作。但由于内存和磁盘速度的差异，需要在中间做一个缓冲。
>
> innoDB内存区域分为：Buffer Pool、LogBuffer。Buffer Pool用于加速数据的访问和修改，通过将热点数据缓存在内存的方法，最大限度地减少磁盘 IO，加速热点数据的读和写。



### redoLog

- **Innodb存储引擎**生成的重做日志。用于**崩溃后修复**数据，保证了事务的**持久性**。

redoLog主要存在于innoDB的磁盘区域。在内存中做的事务相关操作会同步到磁盘的redoLog日志，确保意外之后，事务数据能被回滚。

事务通常首先在内存中成功，但在内存中成功的事务显然是不行的，需要在真正在磁盘中的操作才算成功。而刷盘是有一定的频率的，在刷盘还未开始的时候，mysql就已崩溃。那么之前在内存中已经成功的事务怎么办？

简单粗暴的解决方法是：

- 在普通操作的时候使用Buffer Pool缓冲。
- 在事务的时候，不再使用Buffer Pool缓冲，每一条事务操作成功后直接马上刷盘。*注：不是跳过内存直接刷盘，而是首先在内存更改后，马上刷盘。*

> 但显然：这种方式不可行，事务不是稀少的操作



#### **事务解决方法**

- 将内存中正在操作的的事务陆续首先保存在一个磁盘日志文件redoLog中。


表文件在磁盘，日志也在磁盘，那么为什么需要在中间添加一个记录日志，而不是直接刷到磁盘中，这不是一样的吗？

#### **bingLog和redoLog区别**

- bingLog在十条数据操作全部成功后才记录


- redoLog在十条数据的每一条操作都会记录


#### **redoLog的特点**

- 日志仅仅记录相关数据，相比表空间存在的所有的数据大大降低。
- 由于**数据量**的影响，在日志中的操作快于表空间。

- 并且redoLog是**顺序写入**

mysql在崩溃后重启时根据redoLog对事务做一个回滚操作。

> readLog主要功能：在事务中间做一个缓冲，使用顺序IO加快读写，并且在崩溃后做一个回滚。



#### **redoLog区分为两部分**

- 内存区域的Log Buffer

- 磁盘区域的redo Log File

![image-20230523151203708](images\image-20230523151203708.png)

#### **redo Log流程**

1. 将需要更新的表以页为单位，从磁盘加载到内存的Buffer Pool
2. 在事务中的每一次操作，实时记录到内存区域的redo Log Buffer，记录的是数据被修改后的值 
3. 在内存中的事务操作成功后，马上刷盘到redo Log File，对 redo log file采用追加写的方式
4. 以一定的频率将内存区域Buffer Poo中的脏页陆续同步到磁盘文件页中

![image-20230523154033430](images\image-20230523154033430.png)

#### **redo Log刷盘策略**

- 这里的刷盘策略指的不是第四步，而是第三步。只要第三步成功后，那么万事大吉了，出现意外反正可以从redo Log File同步到表中。第四步是在非意外的情况下同步到磁盘，相对来说没有那么重要了。

如上图所示，事务成功后：redoLogBuffer会直接刷盘到redoLogFile。但在实际上，现代操作系统为了提高文件写入效率，会在中间增加一个文件系统缓存。所以什么时候从文件系统缓存真正写入到表文件中，是由系统控制的。在系统还未刷盘的时候，数据仍然可能丢失。

针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务时，在什么时候将 redo log buffer 中的日志正真刷新到 redo log file 中。

**它支持的三种策略**

1. 设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步）
2. 设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）
3. 设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。

以默认情况1为例：

![image-20230523154654646](images\image-20230523154654646.png)

#### **redoLogBuffer以及redoLogFile**





### undoLog

- Innodb存储引擎生成的回滚日志。用于事务的**回滚和MVCC**，保证了事务的**原子性**。

#### undoLog用于事务的回滚

undoLog保障了事务的原子性，也就是在事务失败后的回滚。当在事务中每执行一次修改，undoLog会记录一条相反的数据

- insert ，记录insert的主键，在事务回滚后根据主键删除
- delete，记录delete的内容，在事务回滚后重新插入
- update，记录update之前的内容，在事务回滚后再次update

undoLog存在于内存区域，但也需要依靠redoLog在磁盘中进行持久化的保护



#### undoLog用于MVCC

​	undo的另一个作用是MVCC，即在innoDB存储引擎中MVCC的实现是通过undoLog来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。



### bingLog

- Mysql的Server层生成的日志。用于**备份数据**，**集群**等。

在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的`写入时机`不一样。

为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用**两阶段提交**方案。



### 其他日志

MySQL有不同类型的日志文件，用来存储不同类型的日志，分为`二进制日志`、`错误日志`、`通用查询日志`和`慢查询日志`，这也是常用的4种。MySQL 8又新增两种支持的日志：`中继日志`和`数据定义语句日志`。使用这些日志文件，可以查看MySQL内部发生的事情。





## Mysql架构

![image-20230523173839072](images\image-20230523173839072.png)

简化为三层结构： 

1. 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端。
2.  SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关。
3.  存储引擎层：与数据库文件打交道，负责数据的存储和读取。





## InnoDB架构

- innoDB的架构可以区分为物理架构和逻辑存储架构两个部分


### 物理架构

<img src="images\artic.png" alt="images" style="zoom: 80%;" />

#### 内存区域

**为什么需要内存区域？**

- 与redis类似，redis基于内存而快速，需要磁盘保证数据持久化。

- mysql基于磁盘而持久化，需要内存保证高速读写。

内存区域主要的功能：利用内存做缓冲，在读取数据的时候，从磁盘以页为单位缓存在内存区域，后续对该数据的修改优先在内存上对应的页上修改

**InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理**。但是由于CPU速度和磁盘速度之间的鸿沟，**基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能**。

> 由于磁盘速度远小于内存，但如果是随机IO的话，磁盘将会后大量的时间在寻道上。所以在不做数据缓冲并且是随机IO的插入，对磁盘影响是非常大的。所以在数据插入的时候避免主键乱序插入，会设计页分裂的可能（固态同理）
>
> **从事务方面：**
>
> 通常在一个事务中，涉及多个修改操作。但由于内存和磁盘速度的差异，需要在中间做一个缓冲
>
> innoDB内存区域分为：Buffer Pool、LogBuffer。Buffer Pool用于加速数据的访问和修改，通过将热点数据缓存在内存的方法，最大限度地减少磁盘 IO，加速热点数据的读和写
>
> **总结：**主要加速的数据读写，另外是改善了磁盘随机IO
>
> **后台线程：**将内存已经修改后的数据积累后，以一定速率同步到磁盘
>
> 内存的数据和磁盘的数据需要保持一致，是一个需要解决的重点。



#####  **Buffer Pool**

- 在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。

**为什么需要BuferPool？**

​	InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I/O。

**什么是BufferPool？**

​	缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。

**BufferPool数据结构**

缓冲池以Page页为单位，底层采用单链表数据结构管理Page。

根据状态，将Page分为三种类型：

-  free page：空闲page，未被使用。
- clean page：被使用page，数据没有被修改过。
- dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。

由于内存的空间限制，Buffer Pool 仅能容纳最热点的数据。和Redis类似，Buffer Pool 使用最近最少使用算法（Least Recent Used，LRU）算法淘汰非热点数据页。

>  在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。
>
>  容量参数设置： `show variables like 'innodb_buffer_pool_size';`
>
>  Buffer Pool 在存储当前活动数据页的时候，会以预读 Read-ahead 的方式缓存目标数据页临近的数据页。采用分代机制解决预读失败问题



##### **Change Buffer**

​	Change Buffer，更改缓冲区，也可以说是缓冲区中的缓冲区，用于不是唯一的二级索引页。由于二级索引数据的不连续性，导致修改二级索引时需要进行频繁的磁盘 IO 消耗大量性能，故此创建ChangeBufer。

在执行DML语句时，如果这些数据Page 不存在Buffer Pool中，不会直接操作磁盘。

1. 而会将数据变更存在更改缓冲区 Change Buffer 中。
2. 在未来数据被读取时，再将数据合并恢复到Buffer Pool中。
3. 再将合并后的数据刷新到磁盘中。

**Change Buffer的意义是什么?**
	与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘I0。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。

**ChangeBuffer合并到Buffer Pool的时机**

1. 用户使用该二级索引进行查询时。
2. 缓存插入操作时，预估到 page 空间不足可能导致索引页分裂时。
3. 本次缓存操作将导致 ibuf btree 页分裂，且分类后 Change Buffer 大小将超出限制时。
4. master 线程发起 `merge` 命令时
5. 用户对该表进行 `flush` 操作时。

**为什么只有非唯一的二级索引才能使用？**

​	如果是唯一索引，那么就需要判断该值是否唯一，那么该如何判断是否唯一呢？刚才所说ChangeBuffer用于操作不存在BufferPool中的数据，既然不存在于ChangeBuffer，那么就无法检查是否唯一，只能从磁盘检查它是否唯一。如此一来ChangeBuffer便失去了意义。

> 那么聚簇索引不行吗？ 因为：聚簇索引 = 唯一索引



##### **Adaptive Hash Index**

​	自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。

​	hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 

​	InnoDB存储引擎会监控对**表上各索引页**的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引。 自适应哈希索引，无需人工干预，是系统根据情况自动完成。



##### **Log Buffer**

​	Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。



#### 磁盘区域

​	在磁盘中，InnoDB 将所有数据都逻辑地存放在一个空间中，称为表空间（Tablespace）。表空间由段（Segment）、区（extent）、页（Page）组成。

##### 表空间

##### 系统表空间

##### 独立表空间

##### 通用表空间

##### 共享表空间

##### undo表空间

##### 临时表空间



### 逻辑储存结构

InnoDB 的逻辑存储结为：
表空间	`>`	段	`>`	区	`>`	页	`>`行   的包含结构

![image-20230425143122705](images\image-20230425143122705.png)

**1). 表空间** 

​	表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。

 **2). 段** 

​	段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。 

**3). 区**

 区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。 

**4). 页** 

​	页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。 

**5). 行** 

行，InnoDB 存储引擎数据是按行进行存放的。 在行中，默认有两个隐藏字段：

-  Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 
-  Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。



**其他**

query cache

-  存在于Server层，并不是innoDB。查出数据后存到query cache中，后边如果SQL完全相同，则直接从query cache中取。
- 般情况下，关闭query cache性能更好。如果线上环境中99%以上都是只读，很少有更新，再考虑开启query cache吧，否则，就别开了。
- 缺点：性能差（缓存命中条件很苛刻，而且很容易失效），在8.0后取消了。




## MVCC

mvcc是多版本并发控制，**指维护一个数据的多个版本**， 使得读写操作没有冲突。

他的实现依赖于**三个隐藏字段**和**undo Log**以及**read View**

### **隐藏字段**	

- DB_TRX_ID   **最近修改事务ID**，记录插入这条记录或最后一次修改该记录的事务ID。

- DB_ROLL_PTR   回滚指针，**指向这条记录的上一个版本**，用于配合undo log，指向上一个版 本。

- DB_ROW_ID   隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。将在没有字段时添加，如有不再添加。 

如没有设置主键则添加第三个字段DB_ROW_ID ，设置后只有前二个



### **undo Log**

- undoLog是回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。
- 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。
-  而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。

undo log版本链：

在MVCC undoLog 充当版本链

日志会记录原来的版本的数据，因为是通过undo log 日志进行回滚的。



### **read View**

ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。

read  View有四个核心属性：

- 结合readView的属性于undoLog对比即可判断是否可访问该版本

- 不同的隔离级别，生成ReadView的时机不同： 
  - READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。
  - REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。



## 锁

 从锁的粒度来说可以分为三个，全局锁，表级锁，行级锁

 **全局锁**

全局锁可在数据库做逻辑备份的时候使用，解决前后不一致的情况。

但有一个严重问题，全局锁属于一个重量级的操作

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
-  如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。

可使用 `--single-transaction` 解决不一致的问题

```mysql
mysqldump --single-transaction -uroot –p123456 dataname > dataname.sql
```



**对于表级锁，主要分为以下三类：**

 **表锁**

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。

对于表锁，又分为两类：

- 表共享读锁（read lock）

​		A添加读锁，不会影响B客户端二的读，但是会阻塞b客户端的写。

- 表独占写锁（write lock）

​		A添加写锁，会阻塞B客户端的读和写。

总结：读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。



**元数锁**

简单来说**某一张表涉及到未提交的事务时，其他客户端是不能够修改这张表的表结构的**

MDL元数据锁的加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。

MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。



 **意向锁**

什么是意向锁？

- 对列添加行锁后同时会对表添加意向锁，其他客户端在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。

对于意向锁，分为两类:

- 意向共享锁(IS)
  - 由语句select ... lock in share mode添加 。 与 表锁共享锁兼容，与表锁排他锁互斥。
-  意向排他锁(IX)
  - 由insert、update、delete、select...for update添加 。与表锁共 享锁及排他锁都互斥，意向锁之间不会互斥。

*一旦事务提交了，意向共享锁、意向排他锁，都会自动释放*



对于行级锁，分三类为：

- 行锁（Record Lock）

- 间隙锁（Gap Lock）

- 临键锁（Next-Key Lock） 

- InnoDB实现了以下两种类型的行锁：

  共享锁

  排他锁



### 琐类型总结

对于表级锁，主要分为以下三类：

**表锁**   对于表锁又分为两类：

- **表共享读锁**（read lock）只能读，不可写
- **表独占写锁**（write lock）当前可读可写，其他不可读写

-  **元数据锁**  保证表结构不被修改

**意向锁** 添加行锁的同时对表添加意向锁，避免全表扫描

- 对于意向锁，又为两类:

  - 意向共享锁(IS)
  - 意向排他锁(IX)

对于行级锁，分三类为：

- 行锁（Record Lock）

- 间隙锁（Gap Lock）

- 临键锁（Next-Key Lock） 

- InnoDB实现了以下两种类型的行锁：

  共享锁

  排他锁



## innoDB总结

**逻辑结构：**

表空间——段——页——区——行

**架构：**

- 内存区
- 磁盘区

**事务原理：**

- A原子性	undo Log
- C持久性    redo Log+其它三大特性
- I一致性     undo Log + redo Log
- D隔离性    MVCC + 锁

**MVCC：**

表隐藏字段	undo Log版本链	 readView









**常见面试题**



## sql实践

1. 使用覆盖索引查询
2. 使用聚簇索引（主建）查询，避免回表查询
3. 使用索引时候满足最左前缀法则
4. 不使用>和<查询，尽量使用>=和<=避免索引失效
5. 使用or条件时候，左右字段都添加索引，如右边无索引将导致左边原有索引失效
6. 使用like模糊匹配时候，尽量使用右模糊匹配查询，使用左或者左右将到导致索引失效
7. 字段为字符时不使用数字匹配，会存在隐士式里类型转换，导致索引失效
8. 创建索引是尽量创建联合索引，以此以便于使用覆盖查询
9. 创建联合索引时将高频字段放在最左边，以此查询满足最左前缀法则
10. 使用null而不是空字符
11. 指定表主键
12. 主键使用顺序插入



#### 为什么不要使用select *

- 可能会避开覆盖查询，进行一个回表操作，影响查找效率
- 无用的资源消耗，`*`可能查询出始终不会使用的字段
- 增加查询分析器解析成本



##  MYsql优化

MySQL 的性能优化主要在于对 SQL语句和索引的优化

`sql语句/索引`的优化效果/成本高于`数据库表结构`大于`系统配置`大于`硬件`

### 架构优化

- 引入redis缓存

- 读写分离

- 分库分表

- 主从分离


### 硬件优化

从硬件上来说，不管是读操作还是写操作，最终都是要访问磁盘，所以说磁盘的性能决定了数据库的性能。除此还有cpu，可用内存等。可以说硬件决定了上限，可适当升级硬件。

从操作系层面来说，应用文件句柄数、操作系统网络的配置都会影响到 Mysql 性能，windows和linux也有细微差别。

### DB优化

db优化主要提现在配置的优化上面,可以提现为： 日志不能小、缓存足够大、连接要够用。

比如更改默认的连接数，buffer Pool缓存池的大小，如部署在专用服务器上，百分之80的内存可以分配给缓冲池

数据库事务提交后需要将事务对数据页的修改刷（ fsync）到磁盘上，才能保证数据的持久性。这个刷盘，是一个随机写，性能较低，如果每次事务提交都要刷盘，会极大影响数据库的性能。所以innoDB才使用read LOg将随机写优化成顺序写。所以提升缓存也很重要

### 表结构优化

- 遵循数据库设计的三大范式，但在一些时候也可不遵循，进行一个反范式，设计一些冗余字段，避免多表查询
- 选择最合适的字段属性
- 在可能的情况下，尽量把字段设置为NOT NULL,这样在将来执行查询的时候，数据库不用去比较NULL值。

### Sql语句优化

优化之前确定需要优化的库，表，到指定语句

**SQL执行频率**

- 可以先对该数据库查看INSERT、UPDATE、DELETE、SELECT的访问频次，如select占比过低，优化就没有那么必要了。

**慢查询日志**	

- 可以使用慢查询日志来定位哪一些是慢sql，来针对性的进行一个优化。比如设置为1秒。

**profile**	

- 可以使用profile来对该sql的耗费的时间做一个具体的分析，比如：分析，执行用时多少。

**explain**	

- 可以使用explain来对指定sql做一个分析，比如有没有用到索引，查询类型是什么，尽量避免全表扫描。

**sql语句的优化**

- group by  建立索引

- order by  根据常用排序简历索引，注意索引的顺序，避免fileSort

- count  尽量使用cuont（*）

- limit 根据id来做一个嵌套子查询

- insert 手动控制事务，多条数据插入使用批量插入，如超过百万数据插入可以使用loda指令插入

- update  尽量使用主键索引来作为更新条件，避免行锁升级为表锁

- 主键优化	尽量使用顺序插入,因为乱序插入涉及到一个页分裂和页合并的问题。尽量使用自增，减小长度
- 可能的情况用where字句替换HAVING字句
  - 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销

使用连接(JOIN)来代替子查询(Sub-Queries)

多表关联查询时，小表在前，大表在后

使用表的别名

### 索引优化

**创建索引：**

遵循最左前缀法则，将最常用的索引放在最左侧

使用联合索引而不是单列索引，联合索引可以有效提高覆盖查询，注意的是单列和联合索引占用是不一样的

避免在大文本字段创建，如需要可使用前缀索引



**使用索引：** 

在使用前缀索引的时候，需要选择长度最短，但区分性较高的长度

- 前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点 :MySQL 无法使用前缀索引做 ORDER BY和 GROUP BY，也无法使用前缀索引做覆盖扫描

使用联合索引时，遵循最左前缀法则，不要跳过中间索引

避免索引失效场景：or   like   >   数据分布   类型不一致  不满足最左前缀法则  in  

使用覆盖查询，避免回表操作



总结到SQL优化中，就三点:

- 最大化利用索引；
- 尽可能避免全表扫描；
- 减少无效数据的查询；



## 数据库范式

1. 属性不可再分
2. 每一行可以被区分，添加唯一主健
3. 每一个表都不包含其 他表已经包含的非主关键字信息



## 大数据表如何分页查询

- 覆盖索引加子查询形式

  ```mysql
  # 拿取需要分页的主键id
  select * from tb_sku order by id limit 90000,10;
  # 使用主键id来查询
  select * from tb_sku a,(select id from tb_sku order by id limit 2000000,10) a where a.id = b.id;
  ```

  

- 对id添加条件

  ```mysql
  SELECT * FROM T WHERE id > #{ID} LIMIT #{LIMIT}
  ```

  

## Mysql中有哪几种锁

根据范围划分为全局锁、表锁、行锁三个。

- **全局锁**

  全局锁就是对整个数据库加锁,当加读锁之后，任何请求都不能对数据库写。

  使用场景一般为做全局的逻辑备份。如不加锁其他线程可以对数据库进行修改会造成前后数据不一致。

  但主库上备份，在备份期间都不能执行更新，也就是基本上全部业务暂停。

  从库上备份，在备份期间主库同步过来的 binlog 从库都不能执行，也就是会导致主从延迟，数据不一致。

  可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份。它会启动一个事务来保证数据一致性

- **表锁**

  表锁对整个表添加锁,锁粒度大，锁冲突概率高，并发程度低

  表锁可区分为表锁、元数据锁、意向锁

- **行锁**

  行锁对当前行添加锁，锁粒度小，锁冲突概率低，并发程度高，但会出现死锁的情况

  行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁。

  行锁可区分为共享锁和排它锁



## InnoDB 支持的四种事务隔离级别

- read uncommited ： 读到未提交数据
- read committed： 脏读， 不可重复读
- repeatable read： 可重读
- serializable ： 串行事务



## 可以使用多少列创建索引？

 任何标准表最多可以创建 16 个索引列。



## 实践中如何优化 MySQL 

最好是按照以下顺序优化：

1. SQL 语句及索引的优化 
2. 数据库表结构的优化 
3. 系统配置的优化 
4. 硬件的优化



## 优化数据库的方法

1. 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例如’ 省份’、’ 性 别’ 最好适用 ENUM 
2. 使用连接(JOIN)来代替子查询 
3. 适用联合(UNION)来代替手动创建的临时表 
4. 事务处理 
5. 锁定表、优化事务处理 
6. 适用外键， 优化锁定表 
7. 建立索引
8. 优化查询语句



## 什么是索引，有哪些

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。索引是一种数据结构，用来增加数据库数据查询速度。索引数据结构以某种方式引用（指向）数据。

索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。

### 按字段特性分类

- 普通索引	建立在普通字段上的索引被称为普通索引。
- 主键索引    主键索引默认自动创建，只能存在一个

- 唯一索引    建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。

- 全文索引    全文索引一般使用倒排索引实现，于查找文本中的关键词。

### 按数据结构分类

**聚簇索引**

- 聚簇索引每一张表都会使用主键索引来作为聚簇索引，它下面挂的是整个行的数据。如没有主键会使用一个唯一索引来作为聚簇索引，如还是没有，会隐式的生成。


**二级索引**（非聚簇索引）

- 简单来说：二级索引下面是聚簇索引


### 按物理存储分类

**B+tree**

**Hash**

**Full-tex**

### 按字段个数分类

- 单列索引	单列索引即只包含一个字段

- 联合索引    联合索引（多列索引）包含多个字段，频繁查找字段需要在最左侧，满足最左前缀法则。

- 前缀索引    前缀索引属于单列索引，但只包含单列索引的一部分

  >  联合索引可以避免回表查询，提高查询速度，但同时也会降低表数据更新的速度。





## 索引下推

索引下推在5.6推出，用于优化查询，使用在非主键上，有效减少回表次数

如何解决回表次数？

- 它的原理是在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

使用条件：

- 只能用于`range`、 `ref`、 `eq_ref`、`ref_or_null`访问方法；
- 只能用于`InnoDB`和 `MyISAM`存储引擎及其分区表；
- 对`InnoDB`存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;

索引下推实质是将服务层负责的部分事情转交给引擎负责；



## 索引是什么？

- 索引是一种能提高数据库查询效率的数据结构。它可以比作一本字典的目录，可以帮你快速找到对应的记录，减少io次数
- 索引一般存储在磁盘的文件中，它是占用物理空间的。
- 适当的索引能提高查询效率，过多的索引会影响数据库表的插入和更新功能，数据改变索引也需要改变占用cpu资源



## MySQL索引有哪些类型

**数据结构维度**

- B+树索引：所有数据存储在叶子节点，复杂度为`O(logn)`，适合范围查询，io次数少。
- 哈希索引:  适合等值查询，不能范围/排序等查询，不发生hash冲突的情况下，检索效率比较高，一次到位。
- 全文索引：`MyISAM`和`InnoDB`中都支持使用全文索引，一般在文本类型`char,text,varchar`类型上创建，但使用很少。

**物理存储维度**

- 聚集索引：聚集索引就是以主键创建的索引，在叶子节点存储的是表中的数据，查询为覆盖查询，不需要回表。

- 二级索引：二级索引就是以非主键创建的索引，在叶子节点存储的是主键和索引列，可能需要回表。

*myisam不支持聚集索引*

**逻辑维度**

- 主键索引：一种特殊的唯一索引，不允许有空值，主键就是聚集索引。
- 普通索引：`MySQL中`基本索引类型，允许空值和重复值。
- 联合索引：多个字段创建的索引，使用时遵循最左前缀原则。
- 前缀索引：使用字段前一部分创建，可以占用更少的资源。适用于大文本。
- 唯一索引：索引列中的值必须是唯一的，但是允许为空值。
- 空间索引：`MySQL5.7`之后支持空间索引，在空间索引这方面遵循`OpenGIS`几何数据模型规则



## 索引什么时候会失效？

- **or**: 查询条件包含`or`，可能导致索引失效
- **函数运算**：对索引列运算（如，`+、-、*、/`），索引失效。索引字段上使用`（！= 或者 < >，not in）`时，可能会导致索引失效。
- **大于或小于**:  使用>=
- **不满足最左前缀法则**：联合索引，查询时的条件列不是联合索引中的第一个列，索引失效
- **数据分布**：mysql 估计使用全表扫描要比使用索引快,则不使用索引
- **类型不一致**：如果字段类型是字符串，`where`时一定用引号括起来，否则索引失效
- **左模糊匹配**：`like`通配符可能导致索引失效。

左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。

索引字段上使用`is null， is not null`，可能导致索引失效。



## 哪些场景不适合建立索引？

数据量小：数据量少的表，不适合加索引

字段区分度低：区分度低的字段不适合加索引（如性别）

修改大于查询：更新比较频繁的也不适合加索引

`where、group by、order by`等后面没有使用到的字段，不需要建立索引

已经有冗余的索引的情况（比如已经有`a,b`的联合索引，不需要再单独建立`a`索引）



## 为什么要用 B+树，为什么不用二叉树？

**什么是二叉数**

- 如果二叉树特殊化为一个链表，相当于全表扫描。


**平衡二叉树**

- 平衡二叉树相比于二叉查找 树来说，查找效率更稳定，总体的查找速度也更快。因为左右基本一致。


**红黑数**

- 红黑数每一个节点都是黑或红色，上下高度差不超过一，通过左旋/右旋来保证平衡，红黑数也是一个平衡查找二叉树


**B**



**B+**

- b+相对于b树来说，上下结构层次少

- b+树不同于b树每一个，节点都存储数据和索引，b+的数据只存在与页子节点，io查找次数大大减少

- 为什么要用 B+树，为什么不用二叉树以及其他的数据结构

- 都可以归根为b+相比于其他数据结构b+ io次数更少






## 什么是回表？如何减少回表？

回表是从索引获取的数据缺少需要查询的数据，需要再次通过聚集索引获取，这个就叫回表查询

使用覆盖查询，也就是从主键查询，或者创建联合索引。



## 什么是覆盖索引？

当前索引的数据包含所有需要查询的数据就为覆盖查询

```mysql
# 为username创建了普通索引,那么目前这个username就为覆盖索引
select username from db
```

如果通过索引，需要不回表查询的，则当前索引可以为覆盖索引。也就是任何一个索引都可以是覆盖索引，通常的情况下主键索引一直为覆盖索引



## 聊聊索引的最左前缀原则

什么是最左前缀法则？

- 首先最左前缀法则体现在联合索引上，需要在创建和使用上遵守，否则可能导致索引失效
- 如最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。
- 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。跳过的话，后面的排序就无从说起了。
- *注：和使用的语句顺序无关，只要存在即可*

**创建**：

- 将最常使用的索引放在联合索引的最左侧，以便于使用的时候符合原则

**使用**：

```mysql
# 创建普通索引  名字     从  mydb数据库  字段为
create index idx_a_b_c on mydb(uid,username,password);
```

不使用uid将导致username和password失效

不使用username将导致password失效，uid有效

不使用pasword，uid，username有效



## 大表如何添加索引

首先要知道的是**给表添加索引的时候**，**是会对表加锁的**

1. 先创建一张跟原表`A`数据结构相同的新表`B`。
2. 在新表`B`添加需要加上的新索引。
3. 把原表`A`数据导到新表`B`
4. `rename`新表`B`为原表的表名`A`，原表`A`换别的表名；



## 如何知道语句是否走索引查询？

使用explain 查看sql的执行计划，这样就知道是否命中索引了。

主要可以通过  可能使用的索引，实际使用索引，查询复杂度，索引长度分析



## 索引有哪些优缺点？

**什么是索引？**

- 索引是一种可以帮助快速查找数据的数据结构

**优点：**

- 增加查询速度
- 索引可以加快数据查询速度，减少查询时间
- 唯一索引可以保证数据库表中每一行的数据的唯一性

**缺点：**

- 降低修改速度
- 创建索引和维护索引要耗费时间

**原因：**

- 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间
- 以表中的数据进行增、删、改的时候，索引也要动态的维护。

> 但显然：优点远远大于缺点。前提是查询远远大于修改、插入。



## 聚簇索引与非聚簇索引的区别

聚簇索引并不是一种单独的索引类型，而是一种**数据存储方式**。它表示索引结构和数据一起存放的索引。

非聚集索引是**索引结构和数据分开存放的索引**。

**性能：**

- 聚集索引速度比二级索引速度快，因为查询时它直接包含了列的所以数据，是一种覆盖查询，无需回表。
- 二级索引速度通常比较慢，如果查询的字段比较少，那么可能达到覆盖查询，不需要再次回表。
  - 单个字段也可以是覆盖查询，但实际应用不太可能，所以创建二级索引通常倾向于联合索引。

**相同：**

- 都可以帮助快速查询

**为什么设计二级索引？**

**优点：**

​	二级索引这样做的好处是，当数据行发生移动时，不需要修改二级索引的指针（或者说，需要在更新索引的时候），只需要修改聚簇索引的指针。

**缺点：**

​	但是这样也带来了一个缺点，就是当通过二级索引查询数据时，需要先根据二级索引找到主键值，然后再根据主键值在聚簇索引中找到数据行，这就需要两次查找。

所以，二级索引数据不连续性是为了提高数据行的更新效率，但是牺牲了一些查询效率。 

>  *注：myisam不支持聚簇索引*



## 唯一索引比普通索引快吗, 为什么

唯一索引不一定比普通索引快, 还可能慢

- 查询时, 在未使用 limit 1 的情况下, 在匹配到一条数据后, 唯一索引即返回, 普通索引会继续匹配 下一条数据, 发现不匹配后返回. 如此看来唯一索引少了一次匹配, 但实际上这个消耗微乎其微. 
- 更新时, 这个情况就比较复杂了. 普通索引将记录放到 change buffer 中语句就执行完毕了. 而对唯一索引而言, 它必须要校验唯一性, 因此, 必须将数据页读入内存确定没有冲突, 然后才能继续操 作. 对于写多读少的情况, 普通索引利用 change buffer 有效减少了对磁盘的访问次数, 因此普通 索引性能要高于唯一索引

**总结：**

- 查询时，唯一索引比普通索引快，但差距非常小。
- 更新时，唯一索引需要校验唯一性，性能更低。



## 简要说一下数据库范式

1. 属性不可再分
2. 每一列需要具有区分度，通常为主键id
3. 不能包含其它表已有的信息

> **可适当的进行反范式**，可能多一个沉余字段，就可以减少一个联表查询
>
> 第二，三范式都是在前置范式的基础上



## 做过哪些MySQL索引相关优化

1. **使用覆盖查询**
   - 减少回表
2. **避免回表**
   - 使用覆盖查询
3. **使用主键查询**
   - 进行覆盖查询，避免回表
4. **满足最左前缀法则**
   - 避免索引失效
5. **尽量使用主键查询**，
   - 聚簇索引上存储了全部数据, 相比普通索引查询, 减少了回表的消耗.

-  MySQL5.6之后引入了索引下推优化,，通过适当的使用联合索引, 减少回表判断的消耗. 

- 若频繁查询某一列数据, 可以考虑利用覆盖索引避免回表. 

- 联合索引将高频字段放在最左边，避免使用的时候索引失效




## MyISAM和InnoDB的区别有哪些

1. InnoDB支持行锁 					MyISAM不支持行锁
2. InnoDB支持事务		 			MyISAM不支持事务
3. InnoDB支持多MVVC              MyISAM不支持
4. innoDB支持外键		 			MyISAM不支持外键
5. innoDB支持聚集索引             MyISAM只支持二级索引





## MySQL 中有哪几种锁？

从锁粒度划分

**全局锁**：锁定数据库中的所有表。

- 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
- 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。
- 但缺点非常明显，在主库备份会阻塞所有其他操作，业务基本停止，在从库备份也会保证数据同步延时，可添加

**表级锁**：每次操作锁住整张表。

- 每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。

**行级锁**：每次操作锁住对应的行数据。

- 行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高，但可能出现死锁情况。应用在InnoDB存储引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。

  > *MyISAM并不支持行锁*



## MySQL 中有哪些不同的表格？

其实MySQL提供的表类型截至到今天已经有13种，常见的也可以是7种，也可以说有5种

 1、MyISAM2、Heap 3、Merge 4、INNODB 5、MISAM

如果再细化出来，基本上就只有两种：InnoDB、MyIASM两种。



## MySQL 中InnoDB 支持的四种事务隔离级别名称

事务隔离级别是在MVCC下区分开来的

| 隔离级别                                     | 是否脏读 | 不可重复读 | 是否幻读 |
| -------------------------------------------- | -------- | ---------- | -------- |
| Read uncommitted    **读未提交**             | √        | √          | √        |
| Read committed        **读已提交**           | ×        | √          | √        |
| Repeatable Read(默认)  **可重读**            | ×        | ×          | √        |
| Serializable                      **串行化** | ×        | ×          | ×        |

- 可重复读：多个事务同时修改一条记录，这条记录在A事务执行期间是不变的
- Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差



## Mysql悲观锁乐观锁有什么区别？

索引和锁是数据库中的两个核心知识点，隔离级别的实现都是通过锁来完成的。

乐观锁和悲观锁并不是锁，而是锁的设计思想，而对应乐观锁和悲观琐的应该是共享锁和排他锁。



## MySQL里的八小时末处理的机制了解吗？

**什么是八小时末处理？**

- 八小时末处理机制指的是：8小时之内没有应用程序和数据库之间没有任何的通信，mysql将会断开链接。
- 而连接池却认为该连接还是有效的（因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致报错。

**如何解决？**

1.  增加 MySQL 的 wait_timeout 属性的值：将时间修改更长
2.  减少连接池内连接的生存周期
3. . 定期使用连接池内的连接 



## 数据库索引的原理?创建索引的缺点是什么，什么情况索引失效?优化数据库的方法有哪些?

数据库的索引原理需要以具体的数据库为准，但都是大差不差的，基本都是B树。如一些系统的文件使用的索引也是B树。

**以Mysql的索引为列**

- MySql数据库使用的索引结构为B+数，但Mysql使用的B+树不同于通常的B+树，它会在B+树的页子节点曾加一条向左的指针，使其成为的双向链表。

**创建索引的缺点**

什么是索引

-  索引是一种帮助快速查找数据的数据结构，既然是数据，那么需要占用一定的资源。

索引只适用与读多写少的表，为了保证索引的时效性。在数据被更改之后，所以需要重新建立部分索引，主要占用了CPU资源。

索引还需要占用一定的磁盘空间，所以索引一般适用于较短的字段，如有特殊必要可以使用前缀索引。

**索引失效场景**

1. OR
2. Like
3. 数据分布
4. 类型不一致
5. 函数计算
6. 不满足最左前缀法则
7. 使用大于>或小于<  

- 索引失效场景大部分都和B+数的特性：有序性 有关

**数据库如何优化**

- 硬件
  - 更换为高性能的硬件
- 软件
  - **架构**
    - 分库分表
    - 引入缓存
    - 主从集群
    - 连接池优化
    - 操作系统调优
    - 网络
    - ES
  - **数据库配置**
    - 最大链接数量
    - 超时时间
    - 设置内存缓冲区大小
    - 合适的表类型字段
  - **索引**
    - 在读多查少的表建立索引
    - 在区分度高的字段建立索引
    - 创建时满足最左前缀法则，将常用字段放置最左侧
    - 使用时尽量符合最左法则，避免第一个字段失效
    - 针对有需求的大字段建立前缀索引
    - 使用覆盖索引查询
    - 使用聚集索引查询
    - 可以的前提建立联合索引
    - 避免回表
    -   对常用where字段建立索引
    - . . . . . . 
  - **SQL**
    - 插入数据时，使用单条语句批量插入，十万级+数据可以使用Mysql提供的Load指令插入
    - orderBY排序时候，建立索引，避免FileSort ，根据情况建立降/升序索引（Mysql 8.0 引入）
    - 尝试手动控制事务，避免重复提交开启
    - 根据索引删除，避免行锁升级表锁
    - 大数据分页可以嵌套一个Id子查询，或对Id添加>=条件
    - 使用有序行/简短的主键数据插入，避免一些页分裂/合并
    - 避免索引失效场景
    - 使用`explain`/`optimizer_trace`分析慢SQL
    - . . . . . . 
- 总结到SQL优化中，就三点:
  - 最大化利用索引。
  - 尽可能避免全表扫描。
  - 减少无效数据的查询。



## 说一下 mysql 中事务的实现原理

**什么是事务？**

- 事务是一组操作，具有ACID特性，即原子，一致，隔离，持久

**事务四大特性如何 维持？**

- **A**tomicity  原子性         undolog
- **C**onsistency 一致性      undolog+redolog
- **I**solation 隔离性            MVCC + 锁
- **D**urability 持久性          redoLog

mysql中的事务实现原理主要依靠于：readLog、undoLog

着重点应该为MVCC多版本并发事务控制

**什么是MVCC？**

- MVCC全称是Multi-Version Concurrency Control，即多版本事务并发控制，现对数据库的并发访问

**MVCC如何实现？**

MVCC的实现依赖于：三个隐藏字段，ReadView，UndoLOg

- 隐藏字段
- Read View
- undo log





## hm Mysql优化

### 在Mysql中如何定位慢查询

**什么是慢查询**

- 页面加载过慢、接口压测响应时间过长，Sql语句执行时间长

**慢查询主要有那些？**

- 聚合查询
- 多表查询
- 表数据量过大查询
- 深度分页查询



#### **开源工具**

- 如果系统部署了运维的监控系统Skywalking类似的工具，可以使用工具查看接口耗时，哪一个阶段慢，针对性的优化。

#### **自带工具**

**慢查询日志**

使用`slow_query_log=1`在myslq配置文件中开启慢查询日志，

















































































































