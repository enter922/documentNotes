### 面试笔记

每一个回答尽量说出相同和不同点，就算是问不同点,也可以说相同点



### ArrayList 和 Vector 的区别?

两者都实现了List接口，是一个有序且可重复的集合，可以根据下标快速访问元素。两者的迭代器都是快速失败的机制。

两者最主要区别体现在线程同步和扩容。

**vector是线程安全的，arrayList不是线程安全。 Vector增长原来的1倍，还可以设置初始以及增长的空间大小，ArrayList 增加原来的 0.5 倍。**

这两个类都实现了 List 接口，是有序的集合，允许数据重复，可以根据索引获取元素。

Vector是旧的，是 java 一诞生就提供了的，ArrayList java2 时才提供。

> 并不是说有线程安全的需求就使用vector，它大部分是在方法体上添加*synchronized*，效率较低，可选CopyOnWrite或Collections



### 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？

- iterator有2中策略Fail-Fast 与 Fail-Safe，是多线程并发操作集合的一种处理机制。
- java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的 所有的类都是安全失败的。
- **Iterator 的安全失败是基于对底层集合做一份拷贝**，添加的和遍历的数组不是同一个 ，因此，它不受源集合上修改的影响。典型代表是ConcerrentHashMap、CopyOnWriteArrayList。
- **Iterator 的快速失败会记录当前集合长度和开始时集合长度**，每一次next会判断之前和之后的长度是否相同，典型代表是ArrayList，HashMap。
- 尝试在安全失败机制下，对正在遍历的集合进行添加元素，添加时不会抛出异常，当刚刚添加的元素也不会打印出来，因为，安全失败是对原有集合的一份拷贝，元素将被添加到原有的集合，而当前遍历的是拷贝集合。

  > concurrent下的fail-safe是最终一致性的



###  List、Map、Set 三个接口，存取元素时，各有什么特点？

List 与 Set 具有相似性，它们都是单列元素的集合有一个功共同 的父接口，叫 Collection。

添加时Set和List使用add(lement)添加元素，Map使用put(k,v)。获取List可以使用ge(index)，map使用ge(key)，Set只能使用遍历。

**Set 里面不允许有重复的元素且无序,**因为没有实现RandomAccess随机接口，不能使用get获取元素。只能以 Iterator 接口取得所有的元素，再逐一遍历 各个元素。

**List 表示有先后顺序的可重复集合，**也可以使用 add(int index,Obj e)插队到指定位置。每一次add将一个元素添加。并不是把这个对象 本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了这个对象，List 除了可以用Iterator 接口取得所有的元素遍历还可以使用get()来获取。

Map 与 List 和 Set 不同，它是双列的集合并且是顶级接口，存储一对 key/value，不能存储重复的 key。

> 什么是重复和不可重复？判断是否相同使用equals来判定，而equals的前提是hashCode相同，这点在set和map很重要。



### 两个对象equals相同，但却可有不同的 hash code，这句话对不对?

**对**。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，因为判断equals的前提是hashCode相等。那么，它 们的 hashcode 值就必须相等。

arrayList 存储的对象就不用实现 hashcode，这个时候可以只实现equals而不实现hashCode。就可能出现equals相同，hashCode不同的情况，当 然，我们没有理由不实现，通常都会去实现的。

- 拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.
- 开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入
- 再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.



### Java 集合类框架的基本接口有哪些？

**List: **有顺序的 collection，并且可以包含重复元素。

**Map**: 可以把键 (key) 映射到值 (value) 的对象，键不能重复。

**Set**：不包含重复元素的 Collection，并且无插入先后顺序。 

**Collection**：代表一组对象，每一个对象都是它的子元素。



### **HashSet 和 TreeSet 有什么区别？**

-  `HashSet`底层

完全就是在`HashMap`的基础上包了一层，四个构造方法都是初始化一个`HashMap`。只不过存储的时候`value`是默认存储了一个`Object`的静态常量PRESENT，取的时候也是只返回`key`，所以看起来就像`List`一样。add()/remove()/contains()方法三个方法都是直接调用的`HashMap`的实现。**`HashSet`是调用的`HashMap`的`put()`方法，而`put()`方法中有这么一行逻辑，如果`哈希值`和`key`都一样，就会直接拿新值覆盖旧值，而`HashSet`就是利用这个特性来保证唯一性。**因此，它的元素是无序的。

- `TreeSet` 底层

是基于`TreeMap`来实现的，所以底层结构也是红黑树。所以不需要重写`hashCode()`和`equals()`方法来保证唯一性。因为它去重是依靠比较器来去重,**因为结构是红黑树，所以每次插入都会遍历比较来寻找节点插入位置，如果发现某个节点的值是一样的那就会直接覆盖，这样保证了唯一性**。它里面的元素是有序的，**且可排序的**。

hashSet由HashMap实现，是无序的，TreeSet由TreeMap实现的，也就是红黑树实现，是有序且可排序。

> 多数set都依赖于hashSet以及hashMap



### 什么是迭代器 (Iterator)？

Iterator用于屏蔽集合不同的特点，提供一个统一遍历方式，Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返 回迭代 器实例的迭代方法。迭代器可以在向前迭代的过程中删除底层集合的元素，但是不 可以直接调用集合的 remove(Object Obj) 删除，可以通过迭代器的 remove() 方法 删除。

- 如果迭代器的指针已经指向了集合的末尾，那么如果再调用next()会返回NoSuchElementException异常
- 如果调用remove之前没有调用next是不合法的，会抛出IllegalStateException

> 增强for，forEach底层都是使用迭代器



### Iterator 和 ListIterator 的区别是什么？

- Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。
- Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。
- ListIterator 是Collection中的一个接口，同时也实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元 素，获取前一个和后一个元素的索引，等等。
- Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。
- Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。



###  数组 (Array) 和列表 (ArrayList) 有什么区别和使用场景？

- 在存储区别上，Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。因为arrayList存储基本类型会自动拆装箱。
- 在容量上，Array 大小是固定的，ArrayList 的大小是动态变化的。
-  ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。



### LinkedHashMap 的实现原理?

LinkedHashMap 是HashMap的子类，的底层是继承于 `HashMap` 实现的，由一个双向链表所构成。

**与HashMap最大的不同就是LinkedHashMap是有序的**  LinkedHashMap  的排序方式有两种: 默认为写入顺序。

- 根据写入顺序排序。 根据访问顺序排序。

其中 `Entry` 继承于 `HashMap` 的 `Entry`，并新增了上下节点的指针，也就形成了双向链表。还有一个 `header` 的成员变量，是这个双向链表的头结点。



### 深拷贝和浅拷贝的区别是什么?

- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指 向原来的对象。换言之,**浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.** 

- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向 被复制过的新对象。而不再是原有的那些被引用的对象.换言之.**深拷贝把要复制的对象所引用的 对象都复制了一遍**

  > 实则浅拷贝和深拷贝只是相对的，如果一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。



### try catch finally，try里有return，finally还执行么？

**执行**并且finally的执行早于try里面的return

**只有在catch代码关闭了jvm或者jvm错误崩溃，不然finally都会执行**，或则捕获范围不够，没有进入try。

finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的 值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数 返回值是在finally执行前确定的。

> **注意：**finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。



### Java IO与 NIO的区别

​	NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同， NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标 准输入输出NIO，另一套就是网络编程NIO。

IO也指的是BIO，即阻塞的IO，而NIO是非阻塞的。



### java反射的作用与原理

反射是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。

反射能够运行时动态获取类的实例，提代码高灵活性。

**缺点：**

- 性能问题，Java反射机制中包含了一些动态类型，Java虚拟机不能够对这些动态代码进行优化。应该避免在对性能要求很高的程序或经常被执行的代码中使用反射。可以关闭JDK的安全检查来提升反射速度，多次相同反射之后也会进行缓存。

- 相对不安全，破坏了封装性,因为可以暴力反射，获得私有方法和属性

> JVM在默认的情况下会对其进行一个优化，在阈值15之后由本地方法改为直接调用




### Java 中的四种引用及其应用场景是什么？

1. 强引用: 普通的`new User();`创建一个对象时所返回的引用 即为强引用，JVM宁愿抛出OOM也不会回收强引用。
2. 软引用: 若一个对象只能通过软引用到达，**那么这个对象在内存不足时会 被回收**，可用于图片缓存中，内存不足时系统会自动回收不再使用的 Bitmap 
3. 弱引用: 若一个对象只能通过弱引用到达，**那么它就会被回收**（即使内存 充足），同样可用于图片缓存中，这时候只要 Bitmap 不再使用就会被回 收 
4. 虚引用: 虚引用是 Java 中最“弱”的引用，通过它甚至无法获取被引用的对 象，它存在的唯一作用就是当它指向的对象回收时，它本身会被加入到引 用队列中，这样我们可以知道它指向的对象何时被销毁。
5. 终结器引用：

> 为什么提供不同区别的引用？ 有助于GC在回收的区分，还可以帮助程序员掌握对象的生命周期



### ForEach  Iterator  增强for 的区别

forEach是一个方法，在Iterable接口中定义为一个带有默认方法的接口。方法里面有个Consumer类型，它是Java8新增的一个消费型函数式接口。forEach在运行是效率低于for循环。可以说foreach是for语句的特殊简化版本。

Iterator是一个接口，是一种设计模式。可以遍历并选择序列中的对象。

要想使用增强for循环，必须实现Iterable接口。增强for内部也是使用Iterable实现。



### HashMap和hashTabel

两者最大的区别是tabel是线程同步的，而map不是。

- 从**线程安全**来看，HashMap不是线程安全的，在多线程情况下可能遇到并发问题，hashTable是线程安全的，但是通过内部方法添加syn来解决的，效率低下，而且在官方注释中hashTable是保留类，不建议使用。如需要线程安全可使用ConcurrentHashMap。

- 在**结构**上，hashTable一直是数组和链表结构，而hashMap在1.8时改为了数组和链表及红黑树。

- 在**遍历**上，HashTable使用Enumeration，HashMap使用Iterator。

- 在**储存**支持上，hashMap可以允许一个空健和多个空值，会把 null 转化为 0 进行存储，而hashTable由于需要保证线程安全的特性，不允许任何空。否则会造成歧义，即：这个key到底是存在还是不存在。

- 在**容量**上，hashTable默认为11，扩容为2n+1，而hashMap默认为16，扩容为2倍。如添加指定长度，table会直接使用，而map总会扩充为2的n次幂。

- 在**散列**算法上，上HashTable会使用key对hashCode对长度取模，hashMap会做一些扰动来达到更好的分布。

  


### HashMap 和 ConcurrentHashMap

两者最大的区别是ConcurrentHashMap是线程同步的，而HashMap 不是。

- ConcurrentHashMap如同初始容量16，采用了16个Segment数组+hashEntry并且添加分段锁，一个segment只允许一个线程。
- 每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。
- 只要多线程访问容器里不同数据段的数据，就 不会存在锁竞争，提高并发访问率。
- Segment 是一种可重入的锁 ReentrantLock。
- 该类包含两个静态内部类 HashEntry 和 Segment ，前者用来封装映射表的键值对，后者用来充当锁的角色。

在1.8以后摒弃了segment这个概念，改为node数组+链表+红黑树，还能看到segment是因为兼容旧版本。

使用cas+Synchronized来保证线程安全并发（Synchronized在1.6做了很多优化）。

synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发。



### Integer和int的区别

Integer是包装数据类型，而int是其对应的基本类型，同时也是八大基本类型中的一个 。

- 其中，Integer和int会涉及一个拆装箱，Integer到int会进行一个拆箱，int到Integer会进行一个装箱，得益于JDK5引入的自动拆装箱语法糖，而无需手动操作。
- 集合并不能存储诸于int的基本类型，只能存放Integer的包装类型，而由于拆/装箱看起来无异。

1. 在使用上，int可以直接定义赋值、但Integer需要使用new关键字来创建对象。

2. 在默认值上，因为Integer是一个对象，Integer的默认值为null、而int的默认值为0。

3. 在内存上，Integer由于是一个对象，所以 存储在堆内存，int 类型是直接存储在栈空间。
4. 在性能上，由于Integer包装了其他功能，性能要低于int。
5. 在遍历上，由于Integer是对象，提供了更多的方法和工具z类，便于操作。
6. 在缓存上，在Integer中 -128到127之内值会被缓存起来，其中使用到了一个享元设计模式，int并没有缓存。



### 为什么要设计包装类型

首先java是一个面向对象的语言，为了体现一切皆对象的思想，而且对象还可以使用泛型来规范。

可以使用对象对象的一些特征，比如封装，安全性较好，可以对包装类型提供更多的操作方法。在集合中也只能支持对象。



### 什么是双亲委派

简单来说：双亲委派是一种自下而上再下的类加载机制，当一个加载器收到一个加载请求不会尝试去加载它，会把逐层向上委派。如上层无法加载，会向下传递，去尝试加载。

类加载器会有三个，这三个会行程一个层级关系，每一个类加载器会分贝去加载不同范围类的jar包

双亲委派模型代码编写在 CLassLoader 的Class<?> loadClass(String name, *boolean* resolve)方法，简单明了

- `Bootstrap ClassLoader` ， 主 要 是 负 责 Java 核 心 类 库 的 加 载 ， 也 就 是%{JDK_HOME} lib 下的 rt.jar、resources.jar 等
- `Extension ClassLoader`，主要负责%{JDK_HOME} lib ext目录下的jar包和class 文件 
- `Application ClassLoade`r，主要负责当前应用里面的 classpath 下的所有 jar 包 和类文件
- 除了系统自己提供的类加载器以外，还可以通过 ClassLoader 类实现自定义加载器



Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

- 双亲委派模型代码编写在 CLassLoader 的Class<?> loadClass(String name, *boolean* resolve)方法，简单明了。

- 双亲委派模型是一种`从下而上再下`的查找加载机制。

  1. 每当一个类加载器接收到加载请求时，它并不会自己尝试加载，而是将请求委托给父类加载器。

  1. 当加载器发现自己无父类的时候，尝试自己加载，如加载失败将向下依次派遣，如最终无法加载，将抛出异常。

- 双亲委派模型加载时涉及三个类主要加载器， 形成一个层级关系，但并不是使用继承/接口编写的。
- 加载器层级关系使用组合实现，在面向对象编程中，有一条非常经典的设计原则： **组合优于继承，多用组合少用继承。**继承会增加耦合。
- 双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，不少框架都会打破双亲委派模型，如：TomCat

**双亲委派模型的好处**

1. 双亲委派模型可以增加一定的安全性，避免核心类被替换
2. 还可以避免类的重复加载

**沙箱安全机制**



## Redis常见三大问题

- redis三大缓存为缓存穿透、雪崩、击穿。三者发生都会让Redis命中率下降，请求直接打在DB上,导致db的压力变大,影响正常服务。

#### 缓存穿透	(不存在的数据)

产生原因：请求根本不存在的资源。DB本身就不存在，Redis更是不存在，主要是一种攻击行为。

解决方法：

- **对空值进行缓存**   把这些无效的key也添加到redis，value为空，但key设置的过期时间不能太长，防止占用过多资源，

  > 但对空值进行缓存不能解决大量随机key来存储

- **使用布隆过滤器**  当使用随机key来请求，空值进行缓存将不能很好的缓存，所以当一个请求来临的时候先进行布隆过滤器的判断，如果有那么才进行放行，否则就直接拦截,但任然有判断错误的情况。

  > 在Redis中使用luar脚本集成布隆过滤器，不在需要java实现中操作

- **实时监控**   对redis进行实时监控，当发现redis中的命中率下降的时候进行原因的排查

- **接口校验** 对请求参数进行校验，对于id=-382这些无效访问就直接拦截



#### 缓存击穿	(热点数据集中失效)

产生原因：某个或几个热点key时间过期(redis中不存在，mysql存在)，导致db压力剧增影响正常服务。

其实偶尔的击穿是可以接受的，大部分数据都是设置过期时间，到期后自然需要删除，再次从数据库查询同步。

解决方法：

- 对缓存不设置过期时间
- 将热key过期时间随机，避免多个K同时失效
- 添加锁

#### 缓存雪崩	(大面积key失效)

产生原因：

- 设置了相同的过期时间，大量缓存同时过期(大量缓存击穿)，导致所有的发送到`Redis`请求都无法命中数据，只能到数据库中进行查询。
- `Redis`服务器宕机，所有请求都无法经`Redis`来处理，只能转向数据库查询数据。
- 缓存中间件宕机，可使用高可用集群。

解决方法：

- 对缓存添加一定范围随机时间，比如5分钟+-1分钟，避免大量数据在用一个时间过期。
- 提前添加Redis高可用，如主从分布，配置哨兵机制，在主服务失效后，由从服务继续提供服务。



> 首先，在一个成熟的系统里面，对于比较重要的热点数据，必然会有一个专门缓存系统来维护，同时它的过期时间的维护必然和其他业务的key 会有一定的差别。
>
> 而且非常重要的场景，我们还会设计多级缓存系统，如本地缓存 > Nginx > Redis > Tomcat > JVM > DB
>
> 其次，即便是触发了缓存雪崩，数据库本身的容灾能力也并没有那么脆弱，数据库的主从、双主、读写分离这些策略都能够很好的缓解并发流量。
>
> 最后，数据库本身也有最大连接数的限制，超过限制的请求会被拒绝，再结合熔断机制，也能够很好的保护数据库系统，最多就是造成部分用户体验不好。 
>
> 另外，在程序设计上，为了避免缓存未命中导致大量请求穿透到数据库的问题， 还可以在访问数据库这个环节加锁。虽然影响了性能，但是对系统是安全的。



### 什么是hash冲突和解决方案

1. **链地址法**

   对于相同的哈希值，使用链表进行连接。（**HashMap使用此法**）

   在冲突位置添加一个链表，冲突的元素存储在链表

   优点：适合总数经常变化的情况。（因为拉链法中各链表上的结点空间是动态申请的）

   缺点：查询时效率较低。

2. **再哈希法**

   提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。

   缺点：增加了计算时间

3. **建立公共溢出区**

   将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

   缺点：需要更多的空间

4. **开放定址法**

   出现冲突时，以p为基础，产生另一个哈希地址p1，若p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

   缺点：占空间很大



###  Spring的AOP的使用情景有哪些?简述其实现原理

**什么是AOP？**

- AOP即面向切面编程，同时也是Spring核心功能，AOP可以对原有方法进行扩展

**AOP的使用情景有那些？**

- 日志
- 安全
- 异常

AOP个人业务并不是特别多，但在不少框架都AOP的应用

1. Spring V参数校验
2. Spring 事务
3. Spring Security权限检查

**AOP原理？**

- Spring对AOP的实现比较简单，是通过动态代理实现    jdk / cglib

> 相比于JDK，而`CGLib`的代理对象，执行代理方法的速度更快，只是生成代理类的效率较低。



### CGLib和JDK动态代理

- **JDK**
  - Spring默认使用JDK的动态代理实现AOP，类如果实现了接口，Spring就会使用这种方式实现动态代理
  - `JDK`实现动态代理需要两个组件，实现InvocationHandler接口重写invoke，以及Proxy
  - 缺点是需要被代理的类必须实现了接口
  - JDK动态代理实际还是使用到了反射，所以不需要任何依赖
- **CGLib**
  - CGLib直接操作字节码，生成类的子类，重写类的方法完成代理，其中会使用到一个ASM字节码操纵框架
  - `CGLib`实现代理方法的方式是重写父类的方法

CGLib相比于JDK，生成的速度较慢，在但运行的时候性能要优于JDK的动态代理

JDK只能对实现接口代理，而CGLib使用继承代理，所以无法代理final的类和方法



### 不通过构造函数也能创建对象吗

能，除此之外还可以通过其他方式创建对象

1. 反序列化

2. 反射

3. 网络

4. 克隆

   

###  线程同步有几种实现方法,都是什么?

主要区分为阻塞式和非阻塞式，即悲观锁和乐观锁

**非阻塞**

- Volatile
- CAS及tomic系列实现

**阻塞**

- synchronized
- Lock  及Lock的实现
  - ReentrantLock
  - ReentrantReadWriteLock 
- sleep
- wait ( )

























































