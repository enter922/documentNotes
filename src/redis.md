# Redis

**什么是Redis？**																																								createDate  2023/5/4

Redis是现在最受欢迎一个NoSql非关系型的数据库，使用C语言编写。

包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：

- 基于内存运行，性能高效
- 支持分布式，理论上可以无限扩展
- key-value存储系统
- 开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API

Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。

Redis提供的数据类型主要分为5种自有类型和一种自定义类型，这5种自有类型包括：String类型、哈希类型、列表类型、集合类型和顺序集合类型。

> **关系型数据库**是指采用了关系模型来组织数据的数据库，基本保证ACID，简单来说，关系模式就是二维表格模型，也提现在外健上
>
> 主要代表：SQL Server，Oracle,Mysql,PostgreSQL。
>
> **NoSQL非关系型数据库**，主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。

## Redis使用原则

1. 单个数据量不能过大，避免BigKey。

2. 数据使用越频繁，在Redis存储价值越大。

3. 在Redis中的数据不能被频繁修改，频繁修改的数据可能在数据同步上消耗资源过多。

   >  相反非常操作频繁的数据可以在Redis中修改，定时刷新到数据库。



## Key数据淘汰策略

**为什么需要内存回收？**

1. 一台机器的内存是有限且很宝贵的，分配给Redis的空间也是一定的，而Redis是基于内存操作的，所有的数据都是保存在内存中。
2. 在Redis中，set指令可以指定key的过期时间，当过期时间到达以后，key就失效了

基于以上两点，为了保证Redis能继续提供可靠的服务，Redis需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。

在内存不足时候，首先，客户端会发起需要更多内存的申请。其次，Redis检查内存使用情况，如果实际使用内存已经超出最大内存，Redis就会根据用户配置的淘汰策略选出无用的key。

Redis的内存回收主要分为**过期删除策略和内存淘汰策略**两部分。

### 过期删除策略

过期删除策略即删除达到过期时间的key

- 定时删除

- 惰性删除

- 定期删除

### 内存淘汰策略

​	有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。

**常见的内存淘汰策略有哪些？**

1. noeviction：当内存使用超过配置的时候会返回错误，**同时也是默认的规则**
2. allkeys-random：所有数据中随机删除数据 
3. volatile-random：有过期时间的数据中随机删除数据 
4. volatile-ttl：删除剩余有效时间最少的数据 

5. allkeys-lru：所有数据中删除上次使用时间距离现在最久的数据 
6. volatile-lru：有过期时间的数据中删除上次使用时间距离现在最久的数据
7. allkeys-lfu：所有数据中删除使用频率最少的 
8. volatile-lfu：有过期时间的数据中删除使用频率最少的



## Redis常见三大问题

- redis三大缓存为缓存穿透、击穿、雪崩。三者发生都会让Redis命中率下降，请求直接打在DB上,导致db的压力变大,影响正常服务。

#### 缓存穿透	(不存在的数据)

产生原因：请求根本不存在的资源。DB本身就不存在，Redis更是不存在，主要是一种攻击行为。

解决方法：

- **对空值进行缓存**   把这些无效的key也添加到redis，value为空，但key设置的过期时间不能太长，防止占用过多资源，
  
  > 但对空值进行缓存不能解决大量随机key来存储
  
- **使用布隆过滤器**  当使用随机key来请求，空值进行缓存将不能很好的缓存，所以当一个请求来临的时候先进行布隆过滤器的判断，如果有那么才进行放行，否则就直接拦截，但仍然有判断错误的情况。

- **实时监控**   对redis进行实时监控，当发现redis中的命中率下降的时候进行原因的排查。

- **接口校验** 对请求参数进行校验，对于id=-382这些无效访问就直接拦截。



#### 缓存击穿	(热点数据集中失效)

产生原因：某个或几个热点key时间过期(redis中不存在，mysql存在)，导致db压力剧增影响正常服务。

其实偶尔的击穿是可以接受的，大部分数据都是设置过期时间，到期后自然需要删除，再次从数据库查询同步。

解决方法：

- 对缓存不设置过期时间
- 将热key过期时间随机，避免多个K同时失效
- 添加锁

#### 缓存雪崩	(大面积key失效)

产生原因：

- 设置了相同的过期时间，大量缓存同时过期(大量缓存击穿)，导致所有的发送到`Redis`请求都无法命中数据，只能到数据库中进行查询。
- `Redis`服务器宕机，所有请求都无法经`Redis`来处理，只能转向数据库查询数据。
- 缓存中间件宕机，可使用高可用集群。

解决方法：

- 对缓存添加一定范围随机时间，比如5分钟+-1分钟，避免大量数据在用一个时间过期。
- 提前添加主从分布，配置哨兵机制，在主服务失效后，由从服务继续提供服务。



> 首先，在一个成熟的系统里面，对于比较重要的热点数据，必然会有一个专门缓存系统来维护，同时它的过期时间的维护必然和其他业务的key 会有一定的差别。
>
>  而且非常重要的场景，我们还会设计多级缓存系统，如本地缓存 > Nginx > Redis > Tomcat > JVM > DB
>
> 其次，即便是触发了缓存雪崩，数据库本身的容灾能力也并没有那么脆弱，数据库的主从、双主、读写分离这些策略都能够很好的缓解并发流量。
>
> 最后，数据库本身也有最大连接数的限制，超过限制的请求会被拒绝，再结合熔断机制，也能够很好的保护数据库系统，最多就是造成部分用户体验不好。 
>
> 另外，在程序设计上，为了避免缓存未命中导致大量请求穿透到数据库的问题， 还可以在访问数据库这个环节加锁。虽然影响了性能，但是对系统是安全的。



## Redis数据持久化机制

**为什么需要数据持久？**

- 因为Redis将信息保存在内存，得益于在内存工作速度快，但同时也带来了缺点，那就是可能因为断电等原因易丢失。
- 而Redis断电后无法辅助Mysql，Mysql压力将巨增，且数据丢失后只能从数据库同步。
- 可能有一些操作非常频繁的数据直接在Redis中操作，丢失后也无法从数据库同步。

所谓持久化就是将Redis中保存的数据，以指定方式保存在Redis当前服务器的硬盘上，Redis实现持久化有两种策略。

### RDB

- RDB 全称 redis backup file，即数据库快照。就是将当前Redsi中的所有数据转换为二级制的对象，保存在硬盘上。
- 使用`bgsave`触发异步快照，redis会fork一个子进程进行RDB备份，完成后替换旧RDB文件

> 由于全局快照数据过大，RDB只能隔一段时间执行

### AOF

- AOF 全称 Append Only File ，即仅追加指令。就是将Redis执行过的指令保存起来。
- AOF由于追加指令会带来文件过大的问题，带来明显的磁盘IO问题，所以需要对AOF文件压缩和定期写入磁盘。

> 由于redis指令执行过于频繁，AOF需要在内存中缓冲，积累一定的指令后根据刷盘策略写入到磁盘AOF文件

**总结：**

redis的持久化一般通过RDB和AOF配合使用

- 如果数据不能丢失，RDB 和 AOF 混用 
- 如果只作为缓存使用，可以承受几分钟数据丢失话，可以只使用 RDB。



## Redis存储原理，Redis为什么快？

**Redis为什么快？**

- Redis 的大部分操作都在内存中完成，内存中的执行效率本身就很快，并且采用了高效的数据结构，比如哈希表和跳表/哈希槽。
- 使用单线程避免了多线程的竞争，省去了多线程切换带来的时间和性能开销，并且不会出现死锁。
- 采用基于epoll的 I/O 多路复用机制处理大量客户端的 Socket 请求，因为这是基于非阻塞的 I/O 模型，这就让 Redis 可以高效地进行网络通信，I/O 的读写流程也不再阻塞。

总结有4点：在**内存中运行**，epoll**IO复用**，高效的数据结构，单线程避免竞争。

>  **Redis Cluster 怎么实现节点选择？**
>
>  Redis Cluster 采用的是类一致性哈希算法实现节点选择的
>
>  edis Cluster 将自己分成了 16384 个 Slot（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。
>
>  1. 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。
>  2. 再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。
>
>  **总结：**redis主要基于内存运行，并且使用多路IO复用达到高吞吐量





## IO多路复用

>  **导读**
>
>  **IO复用是Redis快速的重要原因之一**
>
>  使用一个进程来处理一个网络连接(一个用户请求)，这样不现实，但同时这样也是同步阻塞网络IO模型的方式。
>
>  这样缺点就是性能差，每个用户请求到来都得占用一个进程来处理，来一个请求就要分配一个进程跟进处理。
>
>  比喻：一个老师教一个学生，这样的VIP家教服务。



### 概念

**什么是IO多路复用**

- 多路：多个客户端连接（连接就是套接字描述符，即socket 或者 channel），指的是多条 TCP 连接
- 复用：用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接  

**为什么需要IO复用** 

- Redis性能瓶颈并不在CPU，由于Redis在于内存工作，所以更多性能瓶颈是网络宽带
- 正如Mysql需要连接池一样，Redis也需要IO复用

**Redis如何提高网络这一块的性能**

- Redis使用基于epoll的多路IO复用，使单线程具备更高的处理能力

**使用IO复用需要解决什么问题**

- 如何发现那些连接已就绪，哪一些连接还需要等待

  > Redis使用epoll来解决那些连接已就绪，这个是Linux自动的，不需要干预

**linux和windows上的Redis**

- 在Linux上运行的Redis速度高于win，因为epoll可以主动让就绪的请求通知到自己



### Redis并发处理架构

Redis 利用 epoll来实现 IO多路复用，将**连接信息和事件**都放到**事件队列**中，一次放到**文件事件分派器**，事件分派器将事件分发给事件**处理器**

![image-20230504203738934](images\image-20230504203738934.png)

​	Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作和等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现

所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 select 、 poll 、 epoll 来配合。多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。

Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）

Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：

- 多个套接字、

- IO多路复用程序、

- 文件事件分派器、

- 事件处理器。



### **Redis的多线程和单线程体现在什么地方**

**单线程**

- **因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型**

**多线程**

- Redis6将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用单线程操作

**这样设计的好处**

- 使用单个工作线程，保证了数据安全性，因为无需管理多线程数据不一致，同时避免了线程上下文切换，造成资源消耗
- 多个IO线程协同工作来解决网络IO的瓶颈问题
- 使用单线程、多线程配合，实现了鱼和熊掌兼得

**什么是Reactor** 

- Reactor 模式要求 **主线程（I/O 处理单元） 只负责监听文件描述符上是否有事件发生**，有的话就立即将该事件**通知**工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。 **读写数据，接受新的连接，以及处理客户请求均在工作线程中完成**。



### Unix网络编程中的五种IO模型

#### **Blocking IO - 阻塞IO**

> 无法同时监听连接和处理

**普通方案**

​	阻塞BIO的模型存在很大的问题，如果客户端与服务端建立了连接，如果这个连接的客户端迟迟不发数据，程就会一直堵塞在read()方法上，这样其他客户端也不能进行连接。

- 缺点：也就是一次只能处理一个客户端，对客户很不友好。
- 解决：使用多线程，一个线程查询新连接，多个线程处理查询连接后的数据。

**多线程**

使用多线程之后，这样read()方法堵塞在每个具体线程上而不堵塞主线程，不影响接受新的连接

- 缺点：但在并发量上来之后，需要创建大量的线程，这其中还涉及到用户状态的切换（上下文的切换），十分耗资源。

  > tomcat7之前就是用BIO多线程来解决多连接

> **总结：使用BIO遇到的问题**
>
> 在阻塞式I/O 模型中，应用程序在从调用 recvfrom开始到它返回,，有数据报准备好这段时间是阻塞的，recvfrom返回成功后，应用进程才能开始处理数据报



#### **NoneBlocking IO - 非阻塞IO**

> NIO将所有连接加入数组，遍历所有数组的连接，处理就绪的连接

在NIO模式中，一切都是非阻塞的：

- accept()方法是非阻塞的，如果没有客户端连接，就返回无连接标识
- read()方法是非阻塞的，如果read()方法读取不到数据就返回空闲中标识，如果读取到数据时只阻塞read()方法读数据的时间

在NIO模式中，只有一个线程：

- 当一个客户端与服务端进行连接，这个socket就会加入到一个数组中，隔一段时间遍历一次
- 看这个socket的read()方法能否读到数据，这样一个线程就能处理多个客户端的连接和读取了

**非阻塞IO即用轮询代替阻塞**，轮训的间隙仍然可以处理其他的请求，但依然无法同时处理过多连接，并且需要在用户态和内核态切换

解决：**将用户态轮询移植到Linux的内核中**，省略用户态和内核态的切换。这个也是epoll多路IO复用

> 总结：
>
> - 在BIO会遇到性能低下的问题
> - 在多线程BIO遇到资源浪费的问题
> - NIO仍然存在资源利用率不高，因为需要轮询所有的连接
> - 而使用IO复用可以解决这些问题

**什么是用户态和内核态**

​	现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

​	针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。



#### **IO multiplexing - IO 多路复用**

> 将用户态的轮询移至内核态：epoll

-  IO 多路复用，这是IO模型的一种，也是经典的Reactor设计模式

**什么是IO多路复用？**

- IO多路复用（IO Multiplexing）一种同步IO模型，单个进程/线程就可以同时处理多个IO请求。
- 一个进程/线程可以监视多个文件句柄，一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作，没有文件句柄就绪时会阻塞应用程序，交出cpu。
- I/O：Input/Output ，输入和输出。网络 I/O
- 多路：多个客户端连接（连接就是套接字描述符，即socket 或者 channel），指的是多条 TCP 连接
- 复用：用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接

**为什么出现IO多复用机制**

在没有使用IO多路复用机制时，有BIO、NIO两种实现方式，但是会出现阻塞或者开销大和资源浪费的的问题。

1. BIO：阻塞

   - > 在单个线程的情况下，无法同时保存连接等待和请求处理，只能首先保证连接等待，当前请求来临后，只能放弃链接等待去处理请求，那么所有后续请求都会被阻塞

2. 多线程BIO：阻塞以及开销大

   - > 1.为了解决如上的问题，可以使用双线程来解决：第一个线程始终保持连接等待，第一个线程收到连接后转交给第二个线程处理。但并发量上来之后，第二个线程的速度无法处理更多的请求
     >
     > 2.使用线程池来解决：设置更多的线程，但不好掌握粒度，并且线程也是非常宝贵的。

3. NIO：由于需要轮询所以的连接，开销大

   - > 当前有10个连接已接入，那么需要一个容器保存该100个连接，由于只有一个线程，那么只能从1-100轮询，查看那些连接已就绪，但实际一遍轮询下来后，可能只有10个连接已真正就绪，其中还涉及户态和内核态切换。开销和浪费比较大



####  **signal driven IO - 信号驱动IO**

- 所谓信号驱动式I/O(signal-driven I/O)，就是预先告知内核，当某个描述符准备发生某件事情的时候，让内核发送一个信号通知应用进程。


#### **asynchronous IO - 异步IO**

- 是进程通过系统调用告知内核启动某个I/O操作，内核启动I/O操作后立刻返回到进程，进程在I/O操作发生期间继续执行程序，当IO操作完成或遭遇错误时，内核以进程在I/O系统调用中指定的某种方式通知进程操作结果。



#### 总结

> 阻塞IO：监听和处理只能二选一，不好
>
> 使用多线程IO：性能瓶颈以及多线程开销很大
>
> 非阻塞IO：使用轮询代替阻塞，需要在用户和内核态切换，仍然有性能消耗
>
> 多路IO：将用户态轮询移植内核态



**五种IO比较**

![image-20230505230343003](images\image-20230505230343003.png)

### select poll epoll

- select poll epoll都是IO多路复用的实现

**什么是文件描述符**

- java一切皆对象，Linux一切皆文件描述符

**select、poll、epoll比较**

|                | select                                             | poll                                             | epoll                                                        |
| -------------- | -------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 操作方式       | 遍历                                               | 遍历                                             | 回调                                                         |
| 数据结构       | bitmap                                             | 数组                                             | 红黑树                                                       |
| 最大连接数     | 1024 (x86) 或 2048(x64)                            | 无上限                                           | 无上限                                                       |
| 最大文件描述符 | 一般有最大限制                                     | 65535                                            | 65535                                                        |
| fd拷贝         | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | fd首次调用epoll ctl拷贝，每次调用epoll_wait不拷贝            |
| 工作效率       | 每次调用都进行线性遍历，时间复杂度为o(n)           | 每次调用都进行线性遍历，时间复杂度为o(n)         | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度Q(1) |

**epoll总结：**

- **select **就是轮询，在Linux上限制个数一般为1024个
- **poll **解决了select的个数限制，但是依然是轮询
- **epoll **解决了个数的限制，同时解决了轮询的方式



> **案列描述**
>
> 模拟一个tcp服务器处理30个客户socket，一个监考老师监考多个学生，谁举手就应答谁。
>
> 假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择：
>
> 第一种选择：按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误,你用循环挨个处理socket，根本不具有并发能力。 
>
> 第二种选择：你创建30个分身线程，每个分身线程检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。
>
> 第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。Linux下的select、poll和epoll就是干这个的。
>
> 将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor反应模式。



## Bigkey

> 在Redis中字符最大为512MB，List等元素程度可以为40亿个。关于bigKey有不同的定义，阿里规范定义如下

**什么是bigKey？**

- bigKey指代的是大的RedisKey，这个大key不是key大，而是指key的value大

**多大算大key？**

- string是value，最大512MB但是>10KB就是bigkey
- list、hash、set和zset，个数超过5000就是bigkey

**大key会有那些问题？**

- 在集群上内存不均，类似数据倾斜，且集群迁移困难
- 超时删除，大key删除作梗
- 自动过期删除，造成阻塞
- 操作bigKey耗时，且在传输过程中导致网络流量阻塞

**bigKey是如何产生？**

- 统计类：某一个报表，数据日积月累

- 社交类：极速攀升的热点数据

- 缓存类：将多余或者较冷的数据加载到缓存

  

### **MoreKey**

**往redis里面插入大量测试数据key**

**生成**

- 生成100W条redis批量设置kv的语句保存在redisTest.txt

- ```shell
  for((i=1;i<=100*10000;i++)); do echo "set k$i v$i" >> /tmp/redisTest.txt ;done;
  # 生成100W条redis批量设置kv的语句(key=kn,value=vn)写入到/tmp目录下的redisTest.txt文件中
  ```

**添加**

- 通过redis管道的`-pipe`命令插入100W大批量数据

- ```shell
  cat /tmp/redisTest.txt | redis-cli -h 127.0.0.1 -p 6379 -a 123456 --pipe
  ```

  ​	

**keys * / flushall / flushdb 危险命令**

- keys * / flushall / flushdb 严禁 在线上使用  

- keys * / flushall / flushdb 会造成阻塞，会导致Redis其他的读写都被延后甚至是超时报错，可能会引起缓存雪崩甚至数据库宕机

- 通过配置禁用危险命令,在redis.conf

  - ```sh
    rename-command FLUSHALL ""
    rename-command FLUSHDB  ""
    rename-command CONFIG   ""
    rename-command KEYS     ""
    ```

**keys * 的弊端**

- 这个指令没有 ofset、limit 参数，是要一次性吐出所有满足条件的 key，由于 redis 是单线程的，其所有操作都是原子的，而 keys 算法是遍历算法，复杂度是 0(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，可能会引起缓存雪崩甚至数据库宕机。

> flushDB删除一百万数据在3秒左右，误用来不及挽回
>
> 一百万数据插入在30多秒
>
> 不用keys * 那么怎么办？



### Scan

- 使用scan 命令代替 keys \*，避免卡顿，Sacnl类似Mysql的limit，但不完全一样
- 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程，以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历，不保证每次执行都返回某个给定数量的元素，支持模糊查询，一次返回的数量不可控，只能是大概率符合count参数

**基本语法**

```mysql
SCAN cursor [MATCH pattern] [COUNT count]
```

- cursor - 游标。
- pattern - 匹配的模式。
- count - 指定从数据集里返回多少元素，默认值为 10 。

**实际演示**

```mysql
# 从  0 开始寻找 15条 以K开头的 key
SCAN  0 MATCH K* COUNT 15
```

**什么是scan**

- SCAN 命令是一个基于游标的迭代器，每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。

SCAN 返回一个包含两个元素的数组， 

第一个元素是用于进行下一次迭代的新游标， 

第二个元素则是一个数组， 这个数组中包含了所有被迭代的元素。如果新游标返回零表示迭代已结束。

**SCAN的遍历顺序**

​	非常特别，它不是从第一维数组的第零位一直遍历到末尾，而是采用了高位进位加法来遍历。之所以使用这样特殊的方式进行遍历，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。



### BigKey的发现、删除、优化

#### **如何发现大Key？**

- 使用bigKeys 和 memory usage发现key

**bigKeys**

- 使用bigKeys给出每种数据结构Top 1 bigkey，同时给出每种数据类型的键值个数+平均大小

- bigKeys只能查询10kb以下的key

- bigKeys

- bigKyes基于scan游标，建议在从节点，本机节点，执行

缺点：bigKeys只能计算每一种数据占用的top1

**menory usage**

- 使用memory usage来计算每个键值的字节数

**其他工具**

#### **如何删除大key？**

- 使用渐进式删除，即：一次删除一部分数据，多次操作后完全删除。具体操作还需要区分数据类型

**String** 

- 对于String一般可使用del，如过于庞大可以使用unlink进行非阻塞删除

**List**

- 使用Itrim浙进式逐步删除，直到全部删除完成

**Hash**

- 使用hscan每次获取少量field-value，再使用hdel删除每个field

**set**

- 使用sscan每次获取部分元素，再使用srem命令删除每个元素

**Zset**

- 使用zscan每次获取部分元素，再使用ZREMRANGEBYRANK命令删除每个元素

#### **BigKey生产调优？**

- 在redis.conf配置文件LAZY FREEING调整非阻塞删除
- 

### BigKey面试题

- 怎么在海量数据中查询某一固定前缀的key？
  - 使用scan的模糊匹配
- 如何生产上限制危险命令的使用？
  - 在redis配置文件中禁用keys *、flushall、flushdb等危险命令的使用
- MEMORY USAGE 命令你用过吗
  - 使用过，相比于keys * 有更多的功能
- 多大算big，如何发现？ 如何删除？ 如何处理？
  - 定义不同，bigKeys、memory usage，渐进式删除
- BigKey调优？ lazyfree？
  - 在配置文件中开启子线程删除
- 数据库有1000w记录，如何遍历。
  - 



> **bigKey总结：**
>
> 什么是bigKey：10kb的String为bigKey，List长度大于5000
>
> bigKey缺点：阻塞其他key的处理
>
> 关于  `flushall  flushdb` 命令：生产环境严格使用，需要在配置文件关闭
>
> 关于 `keys*` 命令：使用scan替代keys*
>
> 如何发现bigKey：bigKeys 或者memory usage
>
> 如何删除bigKey：渐进式删除，即一次删除一部分



## 布隆过滤器

**什么是位图？**

- 位图使用一个比特位来存储当前数组是否存在的一个状态值
- 位图使用一个bit数组，把一个数据使用hash之后落在bit其中的一个位置，通过1对该位置进行标记，适合数据不是特别多的情况

**什么是布隆过滤器？**

布隆过滤器在位图的基础上进行了优化，当一个元素被加入到集合的时候，通过k个散列函数，把这个元素映射到一个位数组中的k个点。

把这些位置设置为1，在数据检索或比较的时候可以使用同样的方式去映射，去观察每一个位置的值是不是1，如果是那么很有可能存在，如果有任何一个位置为0，那么一定不存在。

**布隆过滤器的特点**

- 它实际上是一个很长的二进制数组(初始值为0的bit数组)+一系列随机hash算法映射函数，主要用于判断一个元素是否在集合中
- 特点：布隆过滤器占用内存少，但有一定不正确性：不存在的一定不存在，存在的不一定存在。



## Redis集群

**什么是Redis集群？**

- 在了解什么是Redis之前需要先了解一下什么是集群，简单来说集群即多台机器
- Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。

**为什么需要集群？**

- **由于数据量过大**，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集

  的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。

- Redis集群有不同的模式，分片集群可以支持多个Master

> - redis最小的状态是一台服务器，但出现断电等意外之后，就可能导致整个redis服务下线，使用Mysql压力剧增
> - 虽然redis快，但在更多的吞吐量之上，但个Redis仍然无法承担，且单个服务器硬件的替身也有上限。随着硬件的升级成本增高，带来的上收益逐渐降低。简单粗暴的就是增加服务器个数，这也是微服务惯用手段。
> - 微服务集群还有其他的原因之一就是网络传输需要时间，将不同的服务器部署到不同的地域，用户访问最近的服务器。



### 主从复制

- 使用主从复制的结构来搭配一台备用机器，在主服务master出现问题之后切换到slave



![1657014182997](     images\1657014182997.png)

但实际redis服务器出现意外情况并不多，只要master没有出现意外，slave就没有意义，造成资源浪费

并且master切换到slave也是需要时间的

### 读写分离

- 使用读写分离来让master和slave同时工作

![1657014449976](images\1657014449976.png)

这样的模式slave在master正常工作时也能分担Master的读工作了

但发生故障时候需要将slave切换为master，仍然需要一定的时间

一般通过提前的固定策略



### 哨兵集群

**什么是哨兵模式？**

- 指的是在发生故障的时候可以自动切换
- 吹哨人巡查监控后台master主机是否故障，如果故障了根据投票数自动将某一个从库转换为新主库，继续对外服务

![1657014722404](images\1657014722404.png)

哨兵节点每隔固定时间向所有节点发送请求

如果正常响应认为该节点正常

如果没有响应，认为该节点出现问题，哨兵能自动切换主备机

如果主机master下线,自动切换到备机运行

> 哨兵集群相对于读写分离主要区别之一，可以在故障的时候自动切换

**哨兵集群模式的问题？**

- 由于是集群，部署在不同的服务器，自然需要通过网络来进行通信，由于网络波动或故障等其他的问题可能导致master和slave之间的通信遇到问题
- 或者哨兵判断节点状态时发生了误判，那么就会错误将master下线，降低整体运行性能
- 所以要减少哨兵误判的可能性



### 分片集群

#### 什么是Redis分片集群

- **分片集群可以支持多个Master**和多个salve，容灾能力更高，且上限性能更高。

- 而哨兵集群只有一个节点支持写操作，在无法满足整体性能要求时，系统性能就会到达瓶颈，这时我们就要部署多个支持写操作的节点，**形成水平扩展每个复制集只负责存储整个数据集的一部分**，这个就是分片集群。



![image-20230506223738699](images\image-20230506223738699.png)

#### 分片集群能做什么

1. Redis集群支持多个Master，每个Master又可以挂载多个slave，所以：
   - 读写分离
   - 支持数据的高可用
   - 支持海量数据的读写存储操作
2. 由于Cluster自带Sentinel的故障转移机制，内置了高可用的支持，**无需再去使用哨兵功能**
3. 客户端与Redis的节点连接，不再需要连接集群中所有的节点，只需要任意连接集群中的一个可用节点即可
4. 槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系

> 分片集群相比于普通哨兵集群，可以拥有多个写节点。



#### **redis分片的数据结构组成**

##### **分片所面临的问题**

- 在单机模式下，需要进行数据的缓存时，直接添加即可。
- 但分片拥有多个master，每个Master又可以挂载多个slave。所以到底将数据插入到哪一个master呢？

##### 槽位slot

- redis分片集群没有使用一致性hash，而是引入了 哈希槽的概念。
- Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模后，来决定放置哪一个槽位，该槽位集群的每个节点负责一部分hash槽。

##### **为什么使用槽位划分**

- 方便扩容和缩减容量，以及方便数据查找。

##### 如何确定槽位

**哈希取余**

- 简单有效，但不具有容错性和扩展性

**一致性哈希分区**

- 背景：一致性Hash算法诞生于1997麻省理工学院，计目标是为了解决分布式缓存数据变动和映射问题
- 是什么：一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，通过特定的算法将每一台服务器落在圆环的某一个点，在插入数据的时候仍然通过同样的算法计算Key的值，确定落在圆环的某一个点，这个数据点将沿着顺时针查找，存储在顺时针的第一台服务器
- 优点：具有容错性和扩展性
- 缺点：在节点过少的情况下，容易造成数据倾斜，即大多数的数据几种在一台服务器上

**哈希槽分区**

- 是什么：哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。
- 解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。
- 一个集群只能有16384个槽，集群会记录节点和槽的对应关系，解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取模，余数是几key就落入对应的槽里。HASH_SLOT = CRC16(key) mod 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。



**为什么Redis槽位最大为16384？**

- CRC16算法产生的hash值有16bit，该算法可以产生2^16=65536个值。

(1)**如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。**

- 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb 
- 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为16384时，这块的大小是: 16384÷8÷1024=2kb 
- 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。

(2)**redis的集群主节点数量基本不可能超过1000个。**

- 集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。

(3)**槽位越小，节点少的情况下，压缩比高，容易传输**

- Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。 



>  Redis分片集群不保证强一致性，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令

##### **面试题**

**为什么Redis槽位最大为16384？**

1. 集群需要相互通讯，如果为65536，那么发送心跳信息的消息头达8k，发送的心跳包过于庞大，而16384仅为2k。
2. redis分片集群的设计初衷上线为1000，虽然最大可以为16384。
3. 在节点槽位越少的情况下，就不会造成过多的失真，易于传输。



> Redis集群最大个数：16384 即槽位上限
>
> redis集群最多建议个数：1000



补充

- Redis高效的原因之一就是采用的高效的数据结构，Reedis分片为 0~16383号槽
- 和hashMap类似通过CRC16算法将数据映射到不同槽位上

而分片集群，即使每一个服务器负责不同的槽位，使每一个服务器都具有读/写的功能

1. MasterA负责0~5000

2. MasterB负责5001~10000

3. MasterC负责10001~16383


![1657072179480](images/1657072179480.png)



有了这个集群结构,我们就能更加稳定和更加高效的处理业务请求了

**为了节省哨兵服务器的成本,有些公司在Redis集群中直接添加哨兵功能,既master/slave节点完成数据读写任务的同时也都互相检测它们的健康状态**



## Redis分布式锁

**什么是分布式锁**

> 分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。









## Redis的单线程问题

Redis的单/多线程不仅仅体现在版本上，还提现在Redis区域位置上。

**单线程**

- 使用单个工作线程，保证了数据安全性，因为无需管理多线程数据不一致，同时避免了线程上下文切换，造成资源消耗
- **因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型**
- 为什么使用单线程：
  - Redis在内存中工作，得益于内存的特性（快，丢失数据）所以也无需添加多线程，而造成其他开发/维护的问题
  - 使用单线程模型是 Redis 的开发和维护更简单，因为单线程模型方便开发和调试;
  - 之前计算机多为2/4核，多线程模式也发挥不出性能，而现在都4/8核心，高级服务器芯片甚至64+

**多线程**

- 多个IO线程协同工作来解决网络IO的瓶颈问题

- Redis6将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用单线程操作

- 为什么使用多线程：
  - Redis性能瓶颈并不在CPU，由于Redis在于内存工作，所以更多性能瓶颈是网络宽带
  - 在删除大对象时，会导致操作时间过长，仍然会遇到阻塞，但可以使用惰性删除可以有效的解决性能问题
  - 正如Mysql需要连接池一样，Redis也需要IO复用


**什么是Reactor**

- Reactor 模式要求 **主线程（I/O 处理单元） 只负责监听文件描述符上是否有事件发生**，有的话就立即将该事件**通知**工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。 **读写数据，接受新的连接，以及处理客户请求均在工作线程中完成**。

**工作线程为什么任然是单线程**

- 使用单个工作线程，保证了数据安全性，因为无需管理多线程数据不一致，同时避免了线程上下文切换，造成资源消耗

> 以前的Redis版本说是单线程，其实只有一个主工作线程。但同步、持久化、异步删除等等还是由后台线程来操作的
>
> 上面所说的区域位置：Redis工作线程是单线程的，但是从整个Redis来说，是多线程的



## Redis的常用数据类型有哪些？

Redis类型可以划分为五种，也可以是九种

**常用五种数据类型**

1. **String**：最基本的数据类型，二进制安全的字符串，最大512M。实际建议不超过10kb
2. **List**：按照添加顺序保持顺序的字符串列表。建议不超过5000
3. **Set**：无序的字符串集合，不存在重复的元素。
4. **Zset**：已排序的字符串集合。
5. **Hash**：key-value对格式

**九种数据类型**

- bitmap：更细化的一种操作，以bit为单位。
- hyperloglog：基于概率的数据结构。 # 2.8.9新增
- Geo:地理位置信息储存起来， 并对这些信息进行操作  # 3.2新增
- 流（Stream）# 5.0新增



## 聊一下Redis事务机制

### Redis事务的概念

- Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。
- 在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中，其中之一的原因为执行是单线程的。

**Redis事务没有隔离级别的概念：**

　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

**Redis不保证原子性：**

　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

**Redis事务的三个阶段：**

- 开始事务
- 命令入队
- 执行事务



### 如何实现事务

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。

Redis会将一个事务中的所有命令序列化，然后按顺序执行。但是Redis事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。

- `MULTI`: 用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个**待执行命令队列**中
- `EXEC`：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis不会执行其它事务的命令。
- `DISCARD`：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出
- `WATCH`：Redis的乐观锁机制，利用compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行



### 使用Redis事务遇到的问题

EXEC 之前：入队的命令可能会出错，可能是语法错误，或者严重的内存不足错误，所以在入队前检查，拒绝并且放弃错误的事务

EXEC 之后：单个调用失败，但其他事务组中的命令仍然继续执行，并不会回滚。

 

### 为什么Redis不支持回滚

- Redis的设计初衷就是高效，因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。



> Redis是具有事务的，但不像mysql具有ACID特性，所以在发生错误之后不能回滚
>
> 可以说Redis的事务是虚假的事务



**面试话术：**

- Redis事务其实是把一系列Redis命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。

- 为了弥补不能回滚的问题，Redis会在事务入队时就检查命令，如果命令异常则会放弃整个事务。

- 因此，只要程序员编程是正确的，理论上说Redis会正确执行所有事务，无需回滚。


面试官：如果事务执行一半的时候Redis宕机怎么办？

- Redis有持久化机制，因为可靠性问题，我们一般使用AOF持久化。事务的所有命令也会写入AOF文件，但是如果在执行EXEC命令之前，Redis已经宕机，则AOF文件中事务不完整。使用 `redis-check-aof` 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。



## Redis在项目中的哪些地方有用到?

- **数据缓存**

Redis采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到redis中，这样用户请求时优先从redis中读取，减少数据库压力，提高并发能力。

>  -  热点排行榜
>  -  视频播放量，商品浏览量



-  **异步队列**


Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。而且Redis中还有pub/sub这样的专用结构，用于1对N的消息通信模式。

- **分布式锁**

Redis中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题

- **共享session**


在分布式系统下，服务会部署在不同的tomcat，因此多个tomcat的session无法共享，以前存储在session中的数据无法实现共享，可以用redis代替session，解决分布式系统间数据共享问题。



## 缓存冷热数据分离

**为什么需要分离存储？**

- Redis使用的是内存存储，当需要海量数据存储时，成本非常高。

**什么是缓存冷热数据分离？**

基于**热度统计 的数据分级存储**及数据在内存/硬盘之间的动态交换，从而大幅度降低成本，达到性能与成本的高平衡。

**基本思路**：基于key访问次数(LFU)的热度统计算法识别出热点数据，并将热点数据保留在redis中，对于无访问/访问次数少的数据则转存到硬盘上，如果硬盘的key再次变热，则重新将其加载到redis内存中。

因此，我们就需要在应用程序与缓存服务之间引入代理，实现Redis和SSD之间的切换。



## 多级缓存





## 如何实现数据库与缓存数据一致？

实现方案有下面几种：

- 本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对Redis的修改逻辑，保证一致。
- 跨服务缓存同步：服务A调用了服务B，并对查询结果缓存。服务B数据库修改，可以通过MQ通知服务A，服务A修改Redis缓存数据
- 通用方案：使用Canal框架，伪装成MySQL的salve节点，监听MySQL的binLog变化，然后修改Redis缓存数据



## 什么是IO复用，用故事的方式打开IO多路复用

上午开会，错过了公司食堂的饭点， 中午就和公司的首席架构师一起去楼下的米线店去吃米线。我们到了一看，果然很多人在排队。

架构师马上发话了:曜，请求排队啊: 你看这位收银点菜的，像不像`nginx的反向代理`? 只收请求，不处理。把请求都发给后厨去处理。

我们交了钱，拿着号离开了点餐收银台，找了个座位坐下等餐。

架构师:你看，这就是异步处理，我们下了单就可以离开等待，米线做好了会通过小喇叭“`回调`”我们去取餐:如果同步处理，我们就得在收银台站着等餐，后面的请求无法处理，客户等不及肯定会离开了。

接下里架构师盯着手中的纸质号牌。

架构师:你看，这个纸质号牌在后厨“服务器”那里也有，这不就是表示`会话的ID`吗?有了它就可以把大家给区分开，就不会把我的排骨米线送给别人了。

过了一会，排队的人越来越多，已经有人表示不满了，可是收银员已经满头大汗，忙到极致了。

架构师，你看他这个系统缺乏`弹性扩容`， 现在这么多人，应该增加收银台，可以没有其他收银设备，老板再着急也没用。

老板看到在收银这里帮不了忙，后厨的订单也累积得越来越多， 赶紧跑到后厨亲自去做米线去了。

架构师又发话了:幸亏这个系统的后台有`并行处理能力`，可以随意地增加资源来处理请求(做米线)我说:他就这点儿资源了，除了老板没人再会做米线了。

不知不觉，我们等了20分钟， 但是米线还没上来。

架构师:你看，系统的处理能力达到极限，`超时了`吧。

这时候收银台前排队的人已经不多了，但是还有很多人在等米线。

老板跑过来让这个打扫卫生的去收银，让收银小妹也到后厨帮忙。打扫卫生的做收银也磕磕绊绊的，没有原来的小妹灵活。

架构师:这就叫`服务降级`。为了保证米线的服务，把别的服务都给关闭了。

又过了20分钟，后厨的厨师叫道: 237号，您点的排骨米线没有排骨了，能换成番茄的吗?架构师低声对我说:瞧瞧， 人太多， `系统异常`了。然后他站了起来:不行，系统得进行补偿操作，退费。

























