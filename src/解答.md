### **ArrayList**

容量：jdk8以后初始容量为0，除此之外，还可以在重载的构造器传入指定int数字和集合。

扩容：在第一次添加元素扩容为10，扩容是为1.5倍。如1.5后为小数使用位移。

特性：线性的数组的结构，是有添加顺序的，元素可重复，也可以使用重载的add来指定插入位置。可以为空，不能存储基本类型，因为拆装箱故而看起来没有太大差异。

底层使用数组实现，所以除尾部外的修改效率相对不高，因为头部的操作需要移动元素。因为数组长度不可变特性，每一次扩容实际是新建1.5倍长度的数组，将原有的数据复制到新数组。



### **迭代器有两种策略**

快速失败：在迭代器遍历的使用使用非迭代器来对集合进行修改，会抛出异常快速失败，避免以后的不确定性，原理是每一次next迭代会判迭代前的长度和当前长度，如不一样则抛出异常。ArrayList是典型代表。

安全失败：在迭代器遍历的时候对其修改不会抛出异常，原理是在遍历前会将集合复制一份，遍历和修改的不是同一个集合。CopyOnWriteArrayList是典型代表。



### LinkList和ArrayList

​			LinkList                 											arrayList

底层：双向链表，不需要连续内存       						数组,需要连续内存

查找：中间慢，首尾查找较高，需要沿链表遍历         全局高，可使用下标随机访问

修改：首尾修改效率最高，中间其次           				 除尾部外修改都相对慢，需要移动元素

 

### 线程池

核心线程： 一直保存的线程

最大线程： 最大线程-核心线程=零时线程  =没有任务时销毁

队列：所有线程繁忙的时候，任务会在这里等待

生存时间：临时线程无任务时，存活时间

日期格式：临时线程无任务时，存活单时间单位

拒绝策略：所有线程繁忙时，队列也满的拒绝策略------>抛异常 ->丢弃任务->丢弃最早排队任务->由调用者执行任务

线程工厂：定制线程对象的创建，如名字，是否守护线程



### **线程状态**

新建： new出来的时候还没有运行

运行：调用start启动

- ​		阻塞：琐竞争失败
- ​		等待：调用wait方法
- ​		限时等待：调用sleep方法

销毁：任务执行完毕，与系统资源断开



### lock和synchronized

syn是关键字，可以应用于方法和代码快,	lock是接口，还有不同的实现，粒度比syn小。lock比syn更加灵活

lock功能比syn多，都是悲观琐。竞争少时syn性能好，激烈时lock会好。

syn退出会自动释放，lock需要手动unlock释放。



### Integer和int的区别

integer是一个包装类，其中使用到了享元模式，其中-138到127会被缓存复用

int是八大基本类型中的一个，占四字节，从jdk5以后引入了自动拆装箱，integer和int会自动转化，这一点也提现在集合上

integer因为包装类性能相对于int会稍差一些



### 为什么要设计封装类

更加规范，可以使用泛型，为了体现一切皆对象，



### 四种引用的区别

强引用：在使用new关键字创建出来的时候对象就是强引用

软引用：在内存不足是会被回收

弱引用：被cg回收扫描到时候，会被回收

虚应用：虚引用是java中的最弱的引用，通过它甚至无法找到它对象，唯一的作用是在它的对象本回收的时候，它会被加入到队列。

**Lock和syn**

从归属上，lock属于一个接口，还有不同的实现，适应不用的场景，比如ConcerrentHashMap的Semgent数组使用的lock锁就是lock的可重入的实现。而syn属于java的关键字，用c++使用在jvm中，可使用于代码块和方法上。

lock需要手动释放，syn退出范围后自动使用，lock的锁粒度比syn小，更加灵活。

在竞争少的时候，syn会提供更好的性能，在竞争多的时候lock会提供更好的性能。



### 什么是双亲委派

双亲委派是一种自下而上在下的类加载机制，当一个加载器收到一个加载进去不会尝试去加载它，会把它向上委派到二级，二级继续向上委派到顶级，顶级无法加载后会向下委派，好处是避免一个类被加载多次



### **缓存雪崩和缓存穿透，如何避免**

redis三大问题是缓存雪崩、缓存穿透、缓存击穿

缓存击穿是同一时间大量的热点数据过期，全部从mysql查询，

缓存穿透是redis和mysql都不存在的数据，穿透到了mysql，业内通用的方法是添加布隆过滤器

缓存雪崩是同一时间大量的数据过期，全部从mysql查询，

解决办法可以是，将热点数据添加随机时间，部分还可以设置永不过期，使用缓存预热，



### 什么是ThreadLocal

创建于独立其他线程，专属自己的资源，  可以在一些多线程下，需要修改同一资源，但对资源没有线程安全要求,经典场景就是登录过程



### @Resource和@Autowired的区别

都是用Bean的自动注入

从类型上说R是javax的实现，而A是spring的实现，A默认也只能根据类型来匹配，但可以配合另外一个注解Q来进行名字匹配

R默认根据名字来匹配，没有提供名字则按类型匹配，spring官方目前不推荐使用A来进行字段注入



### Spring两大核心技术

 Spring的两大核心技术是ioc和,AOP是面向切面编程，是对oop面向对象编程的一种补充，oop关注的是类，aop关注的点是一个切面。 Aop可以在不惊动方法原有的基础上对其进行一个增强。且这个增强，不会影响到原本的方法。 Spring对其的实现有几种，比如说环绕前置和后置，异常后置等， aop的经典应用场景，就有登录日志和事物等,可能个人用的并不是特别多，但很多框架都是用aop来进行一个增强，比如说spring validation 的参数校验。

 IOC它是控制反转。是一种思想。他将传统自己新建的对象进行了一个反转，由自己创建对象改变为容器来帮助创建对象，自己只需要使用即可。 IOC在spring的具体实现是DI依赖注入。它可以有更好的解偶操作，然后使用它性能也会更好。不会因为频繁创建对象而带来的性能损耗，它有几种模式，在应用程序启动的时候创建对象和懒惰创建对象，即使用的时候才创建对象，然后还有单列和多列的模式



### HashMap和HashTable

最重要的是map他是不支持线程安全的哈，希table是支持线程安全的，因为线程安全的特性，table它不能储存空健和空值的，

map可以存储，最多一个空健和多个空值，而实际在map的底层上，它存储的并不是空值，而是将其转化为数字零来进行存放。

在构造器指定长度的时候，map会将你传入的参数始终转化为2的n次幂，而table会直接使用你存入的长度。

在结构上最DK1.7以前map是数组和链表，在1.8之后它改为了链表和红黑数，而table是一直没有变化的，其中一个原因就是table它是保留类，不再推荐使用。所以说如果你想需要一个线程安全的map集合的时候，你优先选用的是concurrencyHashMap





### mysql索引的最左前缀如何优化orderby语句

mysql索引指定是在使用联合索引的时候需要遵守的原则，包括创建是和使用时，指的是->如对abc创了索引，使用的的时候不能跳过a索引，直接使用c索引，如跳过了a，那么a后面的索引都将失效，如如使用了a和c，那么所跳过的b后面的索都将失效，所以在创建联合索引的时候需要将最常用的索引放置在最左侧，另外是否失效和使用索引的顺序无光。

可以根据经常排序的字段简历索引，决定是升序索引还是降序索引，避免filesort





### 简述一下事务

**并发事物出现的问题**

脏读   一个食物读取到了其他事物未提交的

不可重复读 

幻读   

**隔离级别：**读未提交 ，读已提交，可重复读，序列化。InnoDB默认级别为可重复读

**特性:**A原子C一致I隔离D持久



### 常量池

常量池区分为运行时常量池和常量池

- 运行常量池位置在方法区的具体实现元空间上（元空间脱离JVM空间在系统内存上）
- 常量池在class文件中



### GC垃圾回收分析

GC查找主要主要分为计数法和可达性分析

**计数法**

如一个对象引用这个对象，那么这个对象引用数则加一，当没有对象引用的时候，即引用数为零的时候，代表无对象引用，这该对象可以被回收，但有一个缺点是涉及数字运算，消耗性能，(无法回收相互引用的对象)

**可达性分析**

从一系列GC Root对象出发，能通过root对象找到对象则不回收，如找不到则不回收

这一系列可以是System Class对象如Object ，String。



### GC垃圾回收算法

主要有标记清除，标记整理，复制

**标记清除**

- 先通过可达性分析进行标记，哪一个对象可以被回收，哪一些不可以
- 将标记的位置添加到可使用内存的表，但是实际未清除
- 标记清除会产生内存碎片，即两端内存中间被回收的内存，无法放入比之前更大的内存

补充：

​	因为不需要整理碎片，速度较快

**标记整理（标记压缩）**

通过可达性分析进行对象的一个标记，确定哪一个对象可以被回收，哪一些不可以

将之前标记的位置进行清除

整理之前清除产生的内存碎片，使其有序

补充：

​	因为需要整理内存碎片，速度相对较慢

**复制**

缺点：需要双倍空间，内存分代回收中的新生代的幸存区采用复制算法，拥有两块幸存区，清除后做一个交换

优点：速度快，空间换时间

补充：

- 不会有内存碎片





### 分代垃圾回收

内存分代回收可以有处于jvm对堆进行更好的内存回收

如果不分代就好比把一个学校的人放在一个教室，不利于教学/回收

分代回收区分为新生代和老年代，新生代GC频繁，因为80%的对象那在新生代朝生夕死，

老年代GC相对较少，对象长期存在

新生代区又划分为伊甸园和2个幸存者区域，默认比列为8:1:1

划分2个幸存者区域是因为采用复制回收，速度快，并且不会存在内存碎片，但需要更多的空间，所以划分2块区域交换回收

然后对象首先分配在伊甸园，一次GC之后，未被回收的对象转移到幸存者区域，并且年龄加一，达到晋升阈值(默认15)后到老年代



### mysql使用innodb引擎，请简述mysql索引的最左前缀如何优化orderby语句

- 对需要排序的字段建立索引

- 尽量避免FileSort

- 根据最常用的升降序来确定简历，或者家里一个升，一个降序。

  

###  JVM 内存模型中，为什么要区分新生代和年老代，对于新生代，为什么又要区分eden 区survial区?

这个所说的应该是分代垃圾回收相关的知识点

区分新生代还老年代还是比较好理解的，是又有对象有不同的生存时间，有的对象需要存活的时间就可能短一些，有的的可能长一些。

如果所以对象放到一个代中，不利于垃圾回收的管理，可以理解成为，将一个学校不同的年级放到一个教室，这样肯定是不行的。

所以在JVM内存模型中，区分为新生代和老年代。

- 对象首先分配在新生代，新生代的对象一般都是存活时间短，80%的对象在新生代从分配到回收。
- 而老年代一般是存活久一些，之前说了对象首先分配到新生代，那么老年代的对象是如何来的？这个就需要说一下新生代的划分

新生代区分为：一个伊甸园，二个幸存者区，默认比列为`8:1:1`

对象首先分配在新生代的伊甸园区，在空间不足的时候会发起一次MinGC，但伊甸园肯定还有正在使用，不能被回收的对象。那么这个对象将会被移动至幸存者区，每一次没有被回收后年龄加一，阈值达到15之后晋升到老年代。

至于为什么要区分二快幸存者区域还需要从垃圾回收算法说起

标记-清除

- 直接将需要回收的对象放入一个表中，标记为已回收（实际未回收），下一个需要分配的从表中查找地址，由于未整理内存，所以速度快。但也可能存在内存碎片，即2个对象中间，不能放入更大的对象。

标记-压缩

- 标记-压缩也可以称呼为标记-整理，和标记-清除类似，但回整理回收后的内存空间，由于需要整理，所以速度相对来说较慢，但不会存在内存碎片。

标记-替换

- 将对象回收之后，与另一块内存区域做一个替换，速度快，但需要占用双倍空间，

而幸存者区域使用这个回收算法，即速度快，也不会发生内存碎片，缺点是需要双倍空间。

至于三个回收算法的标记前缀指的是，判断哪一些对象可以被回收，后面的字段指的是具体怎么回收的。

之前说到为什么分代的原因有对象存活时间不同，其实区别还有一个算法不同。

新生代使用的minGC，而年代使用的Full GC。

MinGC性能更好，而FullGC性能更差，因为FullGC会有一个word then stop，会停止所有线程。

但通常在FUll回收之前会发起一个Min回收。



### Integer和int 的区别

- 首先Integer是一个包装类型，对应的是基本类型的是int

**什么是包装类型？为什么需要包装类型？**

- 包装类型是基本类型对应的**对象型**的包装类型
- 因为Java毕竟是面向对象的一门语言，所有为了体现一切皆对象的思想，需要设计对应的包装类型

在Integer中会将-172—128缓存起来，以便于使用，其中应用了享元设计模式

同时Integer也是由fainl修饰的不可变类型，适用于Hash的键

> 补充：
>
> int 使用=、Integer 使用new
>
> Integer的默认值为null、int的默认值为0。
>
> nteger 存储在堆内存，int 类型是存储在栈空间。



###  Spring的AOP的使用情景有哪些?简述其实现原理

**什么是AOP？**

- AOP即面向切面编程，同时也是Spring核心功能，AOP可以对原有方法进行扩展

**AOP的使用情景有那些？**

- 日志
- 安全

AOP个人业务并不是特别多，但在不少框架都AOP的应用

1. Spring V参数校验
2. Spring 事务
3. Spring Security权限检查

**AOP原理？**

- 通过动态代理实现















































### 真实

#### String和StringBuffer有什么区别？

String通常和StringBuiler以及StringBuffer来比较，中间会有一个迭代的过程。

String即字符串，是最常用的字符，其内部使用char数组实现，但在新JDK改为byte。

String同时也是不可变的final修饰的类，但不可变不仅仅提现在由final修饰上面。

但String并不属于八大基本类型，属于对象类型，在创建的时候通常并不使用new关键字来创建，通常为String s= ”word “，但也使用 String s = new String（”hello“）来创建一个存在于堆空间的对象。

String为何是可变的？

- 通常所说的可变其实在原基础上，添加新字符，组成一个新的对象。

String为何不可变？

- 使用fainl修饰为基本意义的不可变，真正不可变的原因为存放在运行常量池的串池上，即StringTable。StringTable是一个类HashMap的结构，相同的String会复用StringTable的引用，改变后将创建新的字符，旧的字符将被销毁，不可变更符合Hahs的key

但通常在业务上，需要改变字符串类容，但一直创建新的字符串会早餐不必要的性能消耗。

在这种情况下，JDK就提供了StringBuilder，来创建使用append()修改可变的字符类，但在多线程的的情况下可能造成安全问题。

在这种情况下，JDK就提供了StringBuffer，来创建修改线程安全的可变字符串，主要在方法上使用syn来维持线程安全。

- a+b 使用的是StringBuiulder的append追加功能拼接，存放在堆空间，可手动放入方法StringTable

总结：string为不可变，StringBuilder为可变，StringBuffer为可变字符串，并且线程安全。



#### 接口和抽象类的区别？

接口和抽象类都需要被继承和实现才有意义，所以不能使用final来修饰方法和类/接口名

关键字不同

- 接口使用interface，抽象类使用abstaret，由于接口和类的区别，所以接口实现使用implements ，抽象类基础使用extends

- 接口默认使用public  修饰，也只能是public，抽象类可以任意，且可以提供一个默认的模板

接口不能被实例化，不能拥有构造方法，抽象类拥有构造方法，但不能被实例化

接口更多的是一个方法的规范，而抽象类更多的是一个类的模板信息，所以说抽象类提供了比接口更多的数据，在使用的代价上也要更大。

在实现接口的类上，该类需要强制实现接口的全部方法，但可能有时候并不需要这个操作。所以在版本更新之后，接口也可以提供一个默认的方法实现，接口和抽象类的差距被进一步拉小。

在我个人的使用上，接口使用量远大于抽象类。















































































## 常见面试题

**1、== 和 equals 的区别是什么**

==是一个运算符号，在比较基本类型的时候是比较值，在对象的时候使用是比较地址值

equals是一个方法，在Object中定义，默认和==一样，一般会实现该方法，自定义比较规则，如String实现为比较本身的值



**2、两个对象的 hashCode() 相同，则 equals() 也一定为 true?equal()相等的两个对象他们的hashCode()肯定相等？**

在两个对象的hash和equals实现一致的情况下

不一定，一定

**3、说下final关键字？final 能修饰抽象类？**

final表示不可变，修饰基本类型值不可变，对象地址值不可变

不可被实现和继承，所以不能修饰接口和抽象类

修改static必须提供默认值

**4、String、StringBuffer、StringBuilder的区别？**

不可变

线程安全可变

线程不安全可变

**5、String str="i"与 String str=new String("i")一样吗？**

不一样

运行常量池的stringTable

堆空间

**6、String 类的常用方法都有那些？**



**7、接口和抽象类有什么区别？**

修饰符不同

接口跟多的是规范，抽象类更多的是一套模板

在jdk更新中，接口和抽象类的差距被进一步拉小



**8、Java 容器都有哪些？线程安全的集合有哪些？**

collection   list   set      map

CopyOnWriteArrayList，ConcurrentHashMap ，HashTable，Vector，



**9、HashMap 和 Hashtable 有什么区别？HashMap 与 ConcurrentHashMap 的异同**？

线程安全，和不安全

线程安全，和不安全

**10、ArrayList 和 LinkedList 的区别是什么(带拔高点)**

链表和数组

**11、synchronized 和 volatile 的区别是什么？**

syn：原子，可见

volatile：可见，有序

**12、synchronized 和 Lock 有什么区别？(带拔高点)**

关键字和接口



**13、线程的状态机**



**14、sleep和wait区别？**

Thread和Object的归属

**15、说下java锁**

保证多线程操作共享变量安全性



**16、说下线程池参数**

1. 核心线程
2. 最大线程
3. 存活时间
4. 存活单位
5. 队列
6. 拒绝策略
7. 线程工程



**17、说下线程池实现原理：**



**18、说下常见线程池：**



**19、说下线程池状态：**



**20、try catch finally的异常处理（带题目）**

finally一定执行，除了未进入catch，以及jvm退出

不能在finally进行return



**21、java中实现多线程有几种方法？**

4



**22、java中创建对象的几种方式？**

序列化，反射，new，克隆



**23、拦截器和过滤器区别？**

java和spring的提供



**20、springmvc的工作原理**

servlet和handlerMapping



**21、spring@Autoride 和@resouce的区别？Autowired Resource注解的自动装配过程？**

javax和spring，名字和类型



**22、spring Aop中代理的区别？**

动态代理：

1. CGlib
2. 反射



**23、spring bean的作用域？**

1. 单列

2. 多

3. 同http

4. 同session

5. 全局session

   

**24、Spring中ApplicationContext和beanfactory区别？**

1. 延时加载
2. 提供国际化
3. 高级和基本的IOC容器



**25、Spring注入方式？**

1. 接口
2. set
3. 构造器
4. 自动注入



**26、spring bean装配方式**

1. bean
2. compoment



**27、spring的核心组件**

1. 



**28、spring事务的隔离级别**

1. 同innodb隔离级别



**29、spring是线程安全的吗？**

1. 不是吧



**30、spring的常用注解？**

1. bean
2. Service



**31、spring mvc的常用注解？**

1. requestMappiing
2. PutMapping



**32、转发和重定向的区别？**

1. 状态码不同



**33、tcp 和 udp的区别？**

1. 需要握手和不握手



**34、get 和 post 请求有哪些区别？**

1. 主要用于请求数据和提交



**35、tcp 为什么要三次握手，两次不行吗？**

1. 不可以，三次是最少确保对方在线



**35、查询平均成绩大于60分学生的学号和平均成绩**

avg

**36、数据库Sql优化**

1. 最左前缀法则
2. 覆盖查询
3. 减少回表
4. 添加索引
5. 避免索引失效
6. 使用聚集索引





**36、spring boot 和spring cloud的区别？**

微服务和单体



**37、spring cloud和dubbo的区别？**

体系和具体的框架



**38、spring cloud由什么组成？**

网关

远程调用

负载均衡

服务熔断

注册中心

配置中心



**39、缓存和数据库一致性**

先写缓存和后写

伪装数据库savle



**40、redis的基础数据类型**

1. string
2. list
3. set
4. zset
5. hash



**41、redis是单线程还是多线程的，为什么这么快（带拔高点）？**

1. 区分版本和位置

   是多线程和单的结合体

**42、redis持久化方式？**

1. AOF
2. RDB



**43、说下缓存穿透、缓存击穿，缓存雪崩和对应的解决方案**

1. 不存在的数据：布隆过滤器
2. 少量key失效：随机时间
3. 大量key失效：随机时间

**44、redis的内存淘汰策略（带拔高点）**



**45、redis的过期策略**



**46、redis主从复制策略**



**47、redis内存优化策略（带拔高点）**



**47、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来**

使用scan



**48、Redis的内存用完了会发生什么？**

进行随机淘汰































































