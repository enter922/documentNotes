---
date: 2023-4
---



# JVM

首先jvm是一套规范,只要遵守，个人也可以实现。

最常见的是oreale,HotSpot 

![image-20230408151650608](images\image-20230408151650608.png)



首先是java文件编译为class文件

1. CLassLOader: 	jvm使用`CLassLoader`类加载器去加载到内存

2. Methods Area: 	类都放在方法区

3. Heap: 	创建的实例将放在Heap,在调用方法时会用到，程序计数器，方法栈
4. 虚拟机栈：执行的方法会进入栈，但只能有一个互动帧栈，执行完毕后弹出
5. 热点代码：频繁使用的代码会被解释权，即使编译器优化

6. CG: 	垃圾回收器会回收堆中无用的对象

本地方法接口用于调用jvm不便实现的代码，如使用*native*修饰的获取当前时间





## 结构

先学习JVM的内存结构在看GC垃圾回收，在学习部分字节码，后面为内加载最后看JMM



## 程序计数器

- 每一个线程都有一个自己的计数器，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，以便于切换回来后知道上次执行的位置
- 它是**程序控制流**的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 计数器也是唯一一个不存在溢出的问题,它的生命周期随着线程的创建而创建，消亡而消亡
- 如果当前线程执行的 是 native 方法，则这个计数器为空



## 虚拟机栈

每一个线程都需要一个运行空间，**栈是线程运行需要的内存空间**，每一个栈对应一个线程是独自私有的。随线程创建而创建，消亡而消亡

栈是 JVM 运行时数据区域的一个核心，所有的 Java 方法调用都是通过栈来实现的,除了一些 Native 关键字修饰的方法调用是通过本地方法栈实现的，在运行时也需要和其他运行时数据区域比如程序计数器配合

虚拟机栈和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

**栈帧**：

每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。

每一个方法对应一个栈帧，一次方法调用的时候会把对应的栈帧向下压栈，执行完毕后陆续弹出

只能有一个活动栈帧，就是当前执行的方法

**提问:**

- 垃圾回收是否涉及栈内存？

  不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。

- 栈内存分配越大越好吗？

  不是。因为物理内存是一定的/不变的，栈内存越大，可以支持更多的递归f调用，但是可执行的线程数就会越少。

  可以通过虚拟机参数`-Xss`修改默认的1024k

- 方法的局部变量是否线程安全?

  如果方法内部的变量没有逃离方法的作用访问，它是线程安全的。因为每一个线程对应独立的栈，互不影响。

  如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。

  逃离的方式包括但不限于返回值，和方法参数的值传递（值= 地址值）
  
  简单来说如果是static修饰的变量就需要考虑线程安全问题



### 栈内存溢出	SackOverFlowError 

- 栈帧过多导致栈空间过深，从而溢出

​		如果栈帧过多，超出了栈内存的上限，将造成栈溢出。发生的场景有方法错误递归/死循环

- 栈帧过大导致溢出

  比较少见，栈帧一般为局部变量，难以超出上限。可以通过虚拟机参数`-Xss`修改默认的1024k

- 使用第三方库    一般为不得当使用

  

### 线程运行诊断

1. 使用top命令查询进程的cpu占用
2. 使用ps进一步查看线程的状态   ps H  -eo pid,tid,%cpu | grep  进程id
3.    使用JDK的 jstack  线程id
4. 一般问题后再jstack日志的最底层，如cpu占用过高，长时间无响应



### 本地方法栈

本地方法栈的使用是比较多的。在object里面就有native 关键字修饰的方法，它没有自己Java代码的实现，因为部分场景java无法与系统底层交互,所以它是通过本地方法接口来调用底层的c和c++来实现，常用的有获取时间等。



#### 本地方法接口

简单地讲，**一个Native Method是一个Java调用非Java代码的接囗**

本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。

##### 为什么要使用 Native Method？

使用Native Method主要为与Java环境外交互和与操作系统的交互

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。毕竟效率和占用不是java的长处

目前该方法使用的越来越少了，除非是与硬件有关的应用



## 堆

通过new关键字创建的对象都会使用到堆，堆存在垃圾回收机制

从内存回收角 度，Java 堆被分为新生代和老年代

**堆是线程共享的**，需要考虑线程安全问题



### 堆内存溢出  OutOfMemoryError

首先堆里有垃圾回收机制，当对象不被使用后作为垃圾被回收掉，怎么还可能出现这个堆内存耗尽的？

对象可以当做垃圾被回收的一个条件是这个对象不被使用，但是如果不断的产生新对象，而产生的这些新对象，仍然有人在使用他们，那么将不满足回收的条件,这样的对象达到一定的数量后将产生堆内存溢出。

可通过`-Xmx`来设置,可通过设置较小的堆内存来测试，以此暴露出可能的问题



### 堆内存诊断

1. jps 工具
   查看当前系统中有哪些 java 进程
2. jmap 工具
   查看堆内存占用情况 jmap - heap 进程id,可配合休眠使用
3. jconsole 工具
   图形界面的，多功能的监测工具，可以连续监测
4. jvisualvm 工具  更高级的图形化界面
5. **排查：**堆内存回收后大小居高不下的场景，使用jvisualvm 的堆转储快照，查看当前时间各个对象的内存占用



## 方法区

方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。

Class字节码由三部分组成

- 类的基本信息
- 类的一个常量池
- 类中的一些方法定义，包含虚拟机指令

ClassLoader有主要有三个

- Bootstrap 启动类加载器
- Extension 扩展类加载器
- Application 应用程序加载器

是所有线程共享的，他在虚拟机启动的时候创建， 在逻辑上是堆的一部分。

方法去是一个概念，具体的是现实是元空间，1.7则为永久代。

元空间与永久代最大的区别在于：元空间不再虚拟机设置的内存当中，而是使用本地内存。

方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，可能导致方法区的溢出OutOfMemoryErro

-XX:MetaspaceSize 设置初始的元空间大小。一旦触及这个水位线， Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）

<img src="images\image-20230408184438201.png" alt="image-20230408184438201" style="zoom: 80%;" />

> **元空间的垃圾清除**
>
> 元空间的垃圾清除条件比较苛刻，并不是如同堆空间，只要不在被使用，在下次GC扫描即回收。
>
> 在元空间中整个类加载器不在被使用，且类加载器加载的所有类都被回收了才会被卸载。类加载器被回收后，元空间对应的原始数据再回被清除



## 常量池

常量池存在于方法区的元空间，主要分为Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池。

**常量池: **  是一张表，虚拟机指令根据这张常量表的符号引用找到要执行的类名、方法名、参数类型、字面量信息。

**运行时常量池:**    常量池存在于class文件中,当运行的时候class会被加载器加载到内存中。将把常量池里面的符号`#5`替换为真实的内存地址。编译时使用符号应用的原因为，编译时并不能知道内存地址，因此通过符号引用来代替。

**字面量:**   这里的"hello,world"即为字面量,或者一些基本的布尔，数字

使用 javap -v HelloWorld.class显示编译后的详细信息

```java
javap -v UserService.class
//类的基本信息
Classfile /E:/java/SE/handwritingframe/test/service/UserService.class
  Last modified 2023-4-8; size 620 bytes                          
  MD5 checksum b14ed10915f4f4c14802a5f7b675753e                   
  Compiled from "UserService.java"                                
public class com.example.handwritingframe.test.service.UserService
  minor version: 0                                                
  major version: 52                                               
  flags: ACC_PUBLIC, ACC_SUPER  
//常量池
Constant pool:  
   //符号引用：健            值              通过注释直接表示实际类容
   #1 = Methodref          #6.#20         // java/lang/Object."<init>":()V
   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #23            // hello,world
   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #26            // com/example/handwritingframe/test/service/UserService
   #6 = Class              #27            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/example/handwritingframe/test/service/UserService;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
  #16 = Utf8               args
  #17 = Utf8               [Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               UserService.java
  #20 = NameAndType        #7:#8          // "<init>":()V
  #21 = Class              #28            // java/lang/System
  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
  #23 = Utf8               hello,world
  #24 = Class              #31            // java/io/PrintStream
  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
  #26 = Utf8               com/example/handwritingframe/test/service/UserService
  #27 = Utf8               java/lang/Object
  #28 = Utf8               java/lang/System
  #29 = Utf8               out
  #30 = Utf8               Ljava/io/PrintStream;
  #31 = Utf8               java/io/PrintStream
  #32 = Utf8               println
  #33 = Utf8               (Ljava/lang/String;)V
{//方法定义
  public com.example.handwritingframe.test.service.UserService();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/example/handwritingframe/test/service/UserService;
  public static void main(java.lang.String[]);//方法
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1          //#* 所对应的值
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
		 3: ldc           #3                  // String hello,world
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 10: 0
        line 11: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
}
SourceFile: "UserService.java"
```



## 常量池和串池（StringTable）

常量池a存在字节码文件，后加载到运行时常量池a，但这时候还是运行常量池符号，并没有成为java字符串对象a

等待具体执行到哪一行代码的时候(懒惰加载)，将这一行的地址变为a的字符串对象

会准备一个StringTable（底层是用哈希表实现的,），把a作为一个key，去table查找，如没有将放入，如已存在，则引用串池的地址

**总结**

- 常量池中的字符串仅是符号，只有在被用到时才会转化为对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是StringBuilder
- 字符串常量拼接的原理是编译器优化
- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池中

String.intern(); 尝试将对象放入串池,有则不放入，没有则放入，无论放入是否成功，都会返回串池中的字符串对象

**题目解析：** 

```java
String s1 = "a";
String s2 = "b";
String s3 = "ab";
String s4 = s1 + s2; //true?false  false
java中存在编译器优化，会将其优化为使用StringBuilder拼接，并且调用toStirng，而toString中使用的是new String
而new出来的对象将产生在堆，/**所以不相等的原因为对象为不在同一个地方**/，但使用equals则一样（需实现为字符比较）
s1 + s2 == new StringBuilder().append("a").append("b").tostring() new String("ab")
    
String s5 = "a" + "b"; //true?false  true
结果为true，实际为javac编译期间的一个优化，它认为他们都是常量，已经是确定的，不可能是其他值，所以直接拼接
    
	false	
    true
    true
	false
```

*注：普通声明的字符在常量池子，new的字符在堆*



### stringTable 位置

1.8的stringTable（串池）移动到了堆，StringTable使用非常频繁，所以效率（空间/时间）很重要。

而StringTable在堆上`的`回收效比永久代`的`常量池里`的`stringTable效率高



### StringTable垃圾回收

stringTable的字符并不是永久存在，将在内存不足的时候进行回收



### StringTable调优

- 使用`-XX:StringTableSize=2000`将桶个数将table长度调整为大，减小hash碰撞概率
- 考虑将使用`String.intern();`将字符串对象添加如串池，因为堆会有多个同一值对象，而串池只保存一份唯一值



## 直接内存

- 常见于 NIO 操作时，通过存在堆中的`DirectByteBuffer`操作Native内存，用于数据缓冲区
- 分配回收成本较高，但读写性能高
- 不受 JVM 内存回收管理，也不是jvm规范的，通过unsafe回收

Java不能直接操作文件管理,只能使用使用本地方法进行操作，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 从系统缓冲区复制数据到 java 堆内存中。多出一个步骤，降低了效率。

直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。 

但不存在于jvm的内存区域,，所以GC不能对直接内存回收，但可以通过unsafe.freeMemory来进行释放,unsafe是jvm的类。

一般用 jvm 调优时，会静止显示的 GC:`-XX:+DisableExplicitGC  `。使`System.gc()` 无效。

因为`System.gc()`  是一种Full GC,会回收新生代、老年代，会造成程序回收的时间比较长，迫使用户线程暂停，影响性能

所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。



## GC垃圾回收

> 为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制。Java 语言开发者比 C 语言开发者幸福的地方就在于，我们不需要手动释放对象的内存，但这种幸福也有代价的，一旦这种自动化机制出错，我们又不得不去深入理解 GC 回收机制，甚至需要对这些“自动化”的技术实施必要的监控和调节

从计算机组成的角度来讲，所有的程序都是要驻留在内存中运行的。而内存是一 个限制因素(大小)

除此之外，堆也有大小限制。堆要通过垃圾回收机制，来维持它的正常运作，保证对象的分配， 尽可能不造成“内存溢出”

**什么是垃圾**

- 所谓垃圾就是内存中已经没有用的对象。 既然是”垃圾回收"，那就必须知道哪些对象是垃圾。目前的JVM主流中使用一种叫作**可达性分析的算法**来决定对象是否可以被回收。



### 引用计数

一个对象被引用了一次，在当前的对象头上引用次数加一，当这个数子为0，代表可以被回收

**优点**：

- 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。
- 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。

- 具有区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。

**缺点**：

- 无法回收相互引用的对象，每次对象被引用时，都需要去更新计数器，有时间开销，还伴随加减运算，影响性能

### 可达性分析

现在主流的的虚拟机都采用可达性分析算法来确定哪些内容是垃圾。

​	可达性分析把内存中所有的对象之间的引用关系看作一张图，从一组根对象Gc Root开始往下扫描所有节点，直到扫描完毕。没有被根节点直接或间接引用的对象可以被回收

Gc Root是一系列对象，可以是

- System Class 系统类Object String
- Thread 线程活动  类栈帧局部对象
- Native Stack 本地方法对象
- Busy Monitor 锁

> 可达性的核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收
>
> 全局变量同静态变量不同，它不会被当作 GC Root



### 什么时候回收

不同的虚拟机实现都有不同的回收策略，不过通常可区分为两种

1. `Allocation Failure`：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC。
2. `System.gc()`：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。

> 但在实际的开发中，`System.gc()`可能被禁用，因为system.gc属于一种Full GC，会造成stw（stop then word),即暂停所有线程，影响性能

**finalize**

但在另外一个层次来说，在一个A对象被判断为可以回收的时候，并不会马上被回收。

对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先**会判断这个对象是否执行了finalize方法**，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。

​	finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。



## 四种引用

jvm提供引用可以让程序员通过代码的方式决定对象的生命周期，还有助于jvm进行垃圾回收，比如强引用不被回收，弱引用则扫描即回收

软引用，弱引用可以配合引用队列来释放软引用自身

1. **强引用**(StronglyReference) 

   普通的 User user = new User()；即为强引用，它永远不会被回收，jvm宁愿抛出**O**ut**O**f**M**emory也不会回收

2. **软引用**(SoftReference)  

   如对象具有软应用，内存充足时不会回收， 内存不够时才回收。软引用适合做缓存，在内存足够时，直接通过软引用取值，无需从真 实来源中查询数据，可以显著地提升网站性能。

3. **弱引用**(Weak Reference) 

   Full GC扫描即回收

4. **虚引用**(Phantom Reference) 

   对象退化到虚引用即被回收，必须配合引用队列，用于跟踪对象回收

5. **终结器引用**

​		



## 垃圾回收算法

### 标记-清除

1. 先使用可达性分析从根对象开始扫描，如没有被直接引用或间接引用，则先标记

2. 将先前标记的空间释放，但释放并不会直接清零，而是将地址放入空闲地址列表，下次分配对象从列表查找空闲地址

因为并没有实际清零，容易产生内存碎片。因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。意思是，之前的空闲列表的每一个空闲位置，不能放入现在过大的对象。

并且效率较低，标记和清除两个动作都需要遍历所有的对象

### 标记-整理

标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法，最主要的区别是不会产生内存碎片。

1. 从根对象通过可达性分析标记垃圾。

2. 将被标记的地址向右重排序，使其有序无空闲，清除左侧不需要的对象

3. 将先前标记的空间释放清零，

标记-整理不会产生内存碎片，由于需要将内存地址重排序，需要改变所属对象的地址，比标记-清除多出一步操作，因此效率相对低

### 复制

复制的核心观点是将原有的内存空间分为两块，每次只使用其中一块

1. 将内存区域分成两部分，每次操作其中一个
2. 在垃圾回收时，将正在使用 的内存中的存活对象复制到未使用的内存块中
3. 清除正在使用的内存块中 的所有对象，交换两个内存的角色，完成垃圾回收
4. 周而复始

优点：复制并不会产生内存碎片，在垃圾对象越多的情况，效率越高，因为需要移动的对象变少。

缺点：但需要双倍空间，并且同时只能使用一半的空间，不适用于每一次垃圾比较少的场景。



## 分代

![image-20230409134758721](E:\java\doc\jvm\images\image-20230409134758721.png)

Java 虚拟机根据对象存活的周期不同将堆空间进行区分，**分代的唯一理由就是优化GC性能**，如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。

### 新生代

对象首先分配在新生代的伊甸园区域，新生代的类对象的创建和消亡都非常迅速，常规应用进行一次垃圾收集一般可以回收 70%~95% 的空间，回收效率很高。

新生代又区分为一个伊甸园和二个幸存者区，它们的默认比列为8:1:1，划分2块Survivor原因为采用复制算法效率较高

#### 伊甸园

绝大多数对象首先分配在伊甸园区域，当Eden区第一次没有足够的空间进行分配时，虚拟机将发起一次Minor GC

1. 先将Eden区域有用的对象进行标记
2. 将标记的对象移动到Survivor0区域，并将Survivor0 和Survivor1进行一次交换，每一次交换存活下来的对象年龄加一
3. 直接清除所有的Eden区域

### 幸存区 From

新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to

- 最大阈值为15的时候会晋升到老年代，同时也是默认阈值


### 幸存区 TO

幸存区使用标记复制算法

对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被幸存区容纳的话，将被移动到幸存区空间中

> 新生代再次划分的优势：
>
> 区分二个幸存者区域，在伊甸园需要的对象被移动至幸存者区域
>
> 由于伊甸园的有用对象被移动幸存者区域，伊甸园可直接清空，而不需要标记后整理，也不会产生一个内存碎片
>
> 二块幸存者区域可以使用标记复制清除算法，效率高，缺点是需要双倍空间

### 老年代

在新生代中经历了多次GC后仍然存活下来的对象会进入老年代中，也就是当对象寿命超过阈值时，这个最大寿命是15（4bit），老年代的内存大小一般比新生代大，能存放更多的对象。

在一些特殊的情况下，一些大对象在新生代内存不足时，会被直接分配至老年代。

老年代对象的生命周期较长，GC回收频率相对低，因为更多，所以回收效率相对慢，通常采用标记-压缩算法进行清除

当老年代空间不足，会先尝试触发 Minor GC，如果之后空间仍不足，那么触发 Full GC，STW的时间更长，所以一般使用禁止`System.gc()`，因为`System.gc()`是一个 Full GC。

> **GC Log 分析**
>
> 新生代和老年代所打印的日志是有区别的：
>
> - 新生代 GC：这一区域的 GC 叫作 Minor GC。因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。
> - 老年代 GC：发生在这一区域的 GC 也叫作Full GC 或者 Major GC 。当出现了 Major GC，经常会伴随至少一次的 Minor GC。



### 新生代晋升的规则

**Eden区满时**

- 进行Minor GC，当Eden和一个Survivor区中依然存活的对象无法放入到Survivor中，则通过分配担保机制提前转移到老年代中。 

**若对象体积太大**

- 新生代无法容纳这个对象，-XX:PretenureSizeThreshold即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对Serial及ParNew两款收集器有效。

**长期存活的对象将进入老年代**

- 虚拟机对每个对象定义了一个对象年龄（Age）计数器。当年龄增加到一定的临界值时，就会晋升到老年代中，该临界值由参数：-XX:MaxTenuringThreshold来设置。
- 如果对象在Eden出生并在第一次发生MinorGC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor中，并且设Age=1；以后每经历一次Minor GC，该对象还存活的话Age=Age+1。

**动态对象年龄判定**

- 虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。



### 分代内存比列

在 Java 中，堆被划分成两个不同的区域：`新生代` ( Young )、`老年代` ( Old )。

新生代 ( Young ) 又被划分为三个区域：`Eden`、`From Survivor`、`To Survivor`。

- 新生代的默认大小为堆空间的1/3
  - 伊甸园默认大小为新生代的8/10
  - 幸存者区域0默认大小为新生代的1/10
  - 幸存者区域1默认大小为新生代的1/10
- 老年代的默认大小为堆空间的2/3

![image-20230508143036706](images\image-20230508143036706.png)

>  新生代和老年代为 1:2
>
>  新生代为8:1:1



### 常见参数

**含义** 								**参数**

堆初始大小					 -Xms

堆最大大小					 -Xmx 或 -XX:MaxHeapSize=size 

新生代大小 					-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 

幸存区比例（动态） 	-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 

幸存区比例					 -XX:SurvivorRatio=ratio 

晋升阈值 						-XX:MaxTenuringThreshold=threshold 

晋升详情 						-XX:+PrintTenuringDistribution

GC详情	 					  -XX:+PrintGCDetails -verbose:gc 

FullGC 前 MinorGC	   -XX:+ScavengeBeforeFullGC



## 垃圾回收器

### 串行

![image-20230409163317969](E:\java\doc\jvm\images\image-20230409163317969.png)

单线程

新生代  复制 

老年代  标记整理



### 吞吐量优先

![image-20230508143036706](images\image-20230409144927055.png)

并行垃圾回收器 (Parallel Garbage Collector)

### 响应时间优先

![image-20230409145519848](images\image-20230409145519848.png)

并发标记扫描垃圾回收器 (CMS Garbage Collector)



1. 初始标记，标记root 
2. 并发标记，沿着root找出剩余
3. 重新标记, 因为并发标记后地址可能改变，需要重新标记
4. 清理





### G1 



<img src="images\image-20230409164157776.png" alt="image-20230409164157776" style="zoom: 50%;" />

- 同时注重吞吐量和低延迟（响应时间）
- 超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域
- 整体上是标记-整理算法，两个区域之间是复制算法

Young Collection：对新生代垃圾收集
Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。
Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。



#### JDK 8u20 字符串去重

- 将所有新分配的字符串（底层是 char[] ）放入一个队列

- 当新生代回收时，G1 并发检查是否有重复的字符串

- 如果字符串的值一样，就让他们引用同一个字符串对象

- 注意，其与 String.intern() 的区别

  - String.intern() 关注的是字符串对象

  - 字符串去重关注的是 char[]

  - 在 JVM 内部，使用了不同的字符串标

优点与缺点

- 节省了大量内存
- 新生代回收时间略微增加，导致略微多占用 CPU

```java
-XX:+UseStringDeduplication
```



#### JDK 8u40 并发标记类卸载

在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类

条件比较苛刻，但在框架使用了自定义加载器还是可以实现的

```java
-XX:CLassUnloadingWithConcurrentMark //默认启用
```



#### JDK 8u60 回收巨型对象

- 一个对象大于region的一半时，就称为巨型对象
- G1不会对巨型对象进行拷贝,因为体量大拷贝效率低
- 回收时被优先考虑
- G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉



#### JDK 9 并发标记起始时间的调整

- 并发标记必须在堆空间占满前完成，否则退化为 FulGC

- JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent

- JDK 9 可以动态调整

  - 进行数据采样并动态调整

  - 总会添加一个安全的空挡空间

  - ```java
    -XX:InitiatingHeapOccupancyPercent 用来设置初始值
    ```

除此之外JDK 9 拥有更高效的回收,宣传250+增强 180+bug修复，详情https://docs.oracle.com/en/java/javase/12/gctuning

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

### Jvm垃圾回收调优

使用命令查看虚拟机运行参数

```java
-XX:+PrintFlagsFinal -version / findstr "GC"
```

调优可以从内存、锁竞争、cpu占用、io

应该根据项目类型出发，是低延时还是高吞吐，从而选择合适的回收器



### 新生代调优

调整新生代大小

#### 新生代幸存区调优

幸存区容量大于等于【当前活跃对象+需要晋升的对象】

 设置合适晋升阈值，让长时间存活的对象尽快晋升



#### 案例

案例1：Full GC 和 Minor GC 频繁
案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）
案例3：老年代充裕情况下，发生 Full GC（jdk1.7）



## 语法糖

匿名内部类

Switch

多态

forEach

枚举




## 类

 类文件结构



## 类加载

### 加载

**加载：**

1.  通过一个类的全限定名获取定义此类的二进制字节流

2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

3.  **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口



通过IO将类的字节码载入方法区的元空间，内部采用 C++ 的 instanceKlass 描述 java 类

它的重要 ﬁeld 有：

- _java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用
- _super 即父类
- _ﬁelds 即成员变量
- _methods 即方法
- _constants 即常量池
- _class_loader 即类加载器
- _vtable 虚方法表
- _itable 接口方法

如果这个类还有父类没有加载，先加载父类

加载和链接可能是交替运行的

**加载class文件的方式：**

1.  从本地系统中直接加载
2.  通过网络获取，典型场景：Web Applet
3.  从zip压缩包中读取，成为日后jar、war格式的基础
4.  运行时计算生成，使用最多的是：动态代理技术
5.  由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见
6.  从加密文件中获取，典型的防Class文件被反编译的保护措施

![image-20230420111024318](images\image-20230420111024318.png)

### 链接

#### **验证**

- 验证类是否符合 JVM规范，安全性检查
- 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证

#### **准备**

为 static 变量分配空间，设置默认值

- static 变量存储于存储于 _java_mirror 末尾 ，DK 7 之前在 instanceKlass 末尾
- static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成
- 如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成
- 如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用

#### 解析

将常量池内的符号引用转换为直接引用的过程



### 初始化

**<cinic>()V 方法**

初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全

此方法不需定义，是javac编译器自动收集类中的所有**类变量**的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法

**发生的时机**
概括得说，类初始化是【懒惰的】

- main 方法所在的类，总会被首先初始化
- 首次访问这个类的静态变量或静态方法时
- 子类初始化，如果父类还没初始化，会引发
- 子类访问父类的静态变量，只会触发父类的初始化
- Class.forName
- new 会导致初始化

不会导致类初始化的情况

- 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化
- 类对象.class 不会触发初始化
- 创建该类的数组不会触发初始化



## 类加载器ClassLoader

- 类加载器是一个负责加载类的抽象类对象，用于实现类加载过程中的加载这一步。
- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。
- 类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。
- JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。大部分类在具体用到的时候才会去加载。

主要的类加载器

1. **`Bootstrap ClassLoader`(启动类加载器)** ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar` 、`resources.jar` 、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。

2. **`Extension ClassLoader`(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

3. **`AppC lassLoader`(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

4. `自定义加载器`

| Bootstrap ClassLoader（启动类加载器）     | JAVA_HOME/jre/lib     | 无法直接访问                |
| ----------------------------------------- | --------------------- | --------------------------- |
| Extension ClassLoader(拓展类加载器)       | JAVA_HOME/jre/lib/ext | 上级为Bootstrap，显示为null |
| Application ClassLoader(应用程序类加载器) | classpath             | 上级为Extension             |
| 自定义类加载器                            | 自定义                | 上级为Application           |



### 双亲委派模型

Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式

- 双亲委派模型代码编写在 CLassLoader 的Class<?> loadClass(String name, *boolean* resolve)方法，简单明了

- 双亲委派模型是一种`从下而上再下`的查找加载机制

  1. 每当一个类加载器接收到加载请求时，它并不会自己尝试加载，而是将请求委托给父类加载器。

  1. 当加载器发现自己无父类的时候，尝试自己加载，如加载失败将向下依次派遣，如最终无法加载，将抛出异常

-  双亲委派模型加载时涉及三个类主要加载器， 形成一个层级关系，但并不是使用继承/接口编写的
-  加载器层级关系使用组合实现，在面向对象编程中，有一条非常经典的设计原则： **组合优于继承，多用组合少用继承。**继承会增加耦合
-  双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，不少框架都会打破双亲委派模型，如：TomCat

**双亲委派模型的好处**

1. 双亲委派模型可以增加一定的安全性，避免核心类被替换
2. 还可以避免类的重复加载

**沙箱安全机制**



## 运行期优化

分层编译



逃逸分析



方法内联



常量折叠



反射优化

在调用次数15以后，会取消通过C++实现的代码，进而使用字节码生成



## 对象

**什么是对象？**

- 这个无需多说

### 对象的创建方式有哪些

1. new：直接使用最常见的new关键字来创建
2. 反序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输
3. 反射：即Constructor的newInstance()，
4. 克隆：即clone()方法，不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法
5. 第三方库 Objenesis

### 对象的实例化

1. 判断对象对应的类是否加载、链接、初始化
2. 为对象分配内存
3. 处理并发问题 
4. 初始化分配到的空间
5. 设置对象的对象头
6. 执行init方法进行初始化



### 对象的内存布局



### 对象的访问定位

- **JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？**







## JMM内存模型

JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。

JMM 体现在以下几个方面

- **原子性** - 保证指令不会受到线程上下文切换的影响
- **可见性** - 保证指令不会受 cpu 缓存的影响
- **有序性** - 保证指令不会受 cpu 指令并行优化的影响



## 可见性

阅读之前先看一个退不出的循环

```java
public static boolean run = true;
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while(run) {
            }
        }, "t1");

        t1.start();
		Thread.sleep(1000);
        log.info("t1 Stop");
        run = false;
    }
```

代码执行结果并没有和预想的一样停止运行输出`t1 Stop`

这是因为t1线程将主内存的run读取保存到了本地内存，当run改变前后，t1一直在本地内存读取run，导致主内存的改变对现场不可见

所以可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

**解决方法:**

- 对run添加volatile关键子修饰，volatile能解决可见性和有序性
- 他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存



## 有序性

阅读之前先了解一下指令重排序

- 编译器和CPU为了提高指令的执行效率可能会进行指令重排序，将一个执行时间较短的代码放到执行时间较长的代码前执行，这使得代码的实际执行顺序可能不是按照我们所认为的顺序进行。
- 指令重排必须遵守as-if-serial语义，即：不管怎么重排序，程序的执行结果不能被改变。
- 指令重排主要发生在编译阶段和运行阶段。
- 指令重排序在单线程的情况下能提高一定运行速度，但在多线程情况下不然，会影响结果正确性。

- 指令重排简单来说，可以在程序结果不受影响的前提下，可以调整指令语句执行顺序。多线程下指令重排会影响正确性。

是否可以重排序:

```java
// 可以重排的例子 
int a = 10; 
int b = 20; 
System.out.println( a + b );//a 和 b 相互不影响
// 不能重排的例子 
int a = 10;
int b = a - 5;   //如果重排序那么 会使用a的默认值0减去5，结果错误为-5
```

有序性最终表述的现象是**CPU是否按照编写代码顺序执行依次执行指令**

**解决方法**

- 使用volatle修饰解决有序性
- 使用synchronized和Lock也可以保证有序性，因为它们的代码变成了同步代码块，自然不会有指令乱序问题。



### Volatile

volatile主要作用有**可见性**和**有序性**

强制将修改后的值刷新到主内存中来保持内存的可见性，让一个线程对共享变量的修改对另一个线程可见。

过 CPU内存屏障禁止编译器指令性重排来保证并发操作的有序性。

 Java 中，Java 并没有直接实现 CAS（Compare And Swap），CAS 相关的实现是通过 C++ 内联汇编的形式实现的。

**要求**

* 掌握线程安全要考虑的三个问题
* 掌握 volatile 能解决哪些问题

**原子性**

* 起因：多线程下，不同线程的**指令发生了交错**导致的共享变量的读写混乱
* 解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性

**可见性**

* 起因：由于**编译器优化、或缓存优化、或 CPU 指令重排序优化**导致的对共享变量所做的修改另外的线程看不到
* 解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见

**有序性**

* 起因：由于**编译器优化、或缓存优化、或 CPU 指令重排序优化**导致指令的实际执行顺序与编写顺序不一致
* 解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果
* 注意：
  * **volatile 变量写**加的屏障是阻止上方其它写操作越过屏障排到 **volatile 变量写**之下
  * **volatile 变量读**加的屏障是阻止下方其它读操作越过屏障排到 **volatile 变量读**之上
  * volatile 读写加入的屏障只能防止同一线程内的指令重排

*注：在jdk5以前volatile存在但实际无效*



## **原子性** 

原子性操作指相应的操作是单一不可分割的操作。只能是全部成功或失败，不能是部分成功部分失败。

单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）

**要想在多线程环境下保证原子性，则可以通过Lock、synchronized来确保。**volatile是无法保证复合操作的原子性。

因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。



### Synchronized

- synchronized 是 Java 中的关键字，是jvm层级的，是利用锁的机制来实现线程同步保障原子性，属于一种互斥锁，是悲观锁的体现。

- synchronized 可以用来给对象和方法或者代码块加锁，当它锁定一个方法或者代码块的时候，同一时刻最多只有一条线程执行这段代码，属于一种互斥锁，同时，synchronized 也具有可见性，但synchronized属于重量级操作，开销更大
- 除了volatile之外，**synchronized除了保证原子还可以保证可见性**，但synchronized属于重量级操作，开销更大

- 在`System.out.println()`中就是用了synchronized来保证字符输出的原子性和可见性，所以sout性能较低，推荐日志框架输出









## CAS

CAS全称比较并交换，体现的是一种乐观锁

cas是不加锁的

上一次读取到的值和共享变量比较

依赖底层unsafe操作

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，避免了切换带来的开销适用于竞争不激烈、多核 CPU的场景下

因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，但如果竞争激烈，可以想到重试必然频警发生，反而效率会受影响



使用cas过于繁琐，可使用jdk的原子实现



## 悲观锁 vs 乐观锁

**要求**

* 掌握悲观锁和乐观锁的区别

**对比悲观锁与乐观锁**

* 悲观锁的代表是 synchronized 和 Lock 锁
  * 其核心思想是【线程只有占有了锁，才能去操作 共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】
  * 线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能
  * 实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会
  * 最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。
  
* 乐观锁的代表是 AtomicInteger，使用 CAS来保证原子性
  * 其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】
  * 由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换
  * 它需要多核 cpu 支持，且线程数不应超过 cpu 核数
  * 最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。



## 公平锁和非公平锁

简单概括为资源分配的均匀和不均匀

**公平锁：**

- 每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。
-  公平锁会降低吞吐量，一般不用
- 公平锁的公平体现
  * **已经处在阻塞队列**中的线程（不考虑超时）始终都是公平的，先进先出
  * 公平锁是指**未处于阻塞队列**中的线程来争抢锁，如果队列不为空，则老实到队尾等待
  * 非公平锁是指**未处于阻塞队列**中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的

**非公平锁：**

- 每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁。
- synchronized是非公平锁的经典代表
- ReentrantLock 默认是非公平锁，当然在创建 ReentrantLock 时，可以手动指定其为公平锁，但 synchronized 只能为非公平锁



**Synchronized和Lock**





## Synchronized优化

从jdk1.6开始对Synchronized做了大幅度优化，用来减少锁竞争带来的上下文切换

阅读之前先解释一些名词:

- 自旋：自我重试，对重量锁的优化
- 锁重入：多次加锁
- 锁升级：偏向锁升级为轻量级锁再升级到重量级锁
- 锁膨胀：轻量级锁升级重量级锁
- 偏向锁：取消锁重入，但撤销偏向锁是重量级操作
- 锁粗化：将同一个对象多次加锁优化为一次
- 锁消除：做逃逸分析
- 重量级锁：轻量级的相对，传统锁
- 轻量级锁：“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的
- 读写分离：CopyOnWriteArrayList，只对写加锁



#### 对象头

synchronized依赖于对象头的信息，故而先了解一下对象头

1. 在JDK 1.6的JVM中，对象实例在**堆内存**中被分为三部分：**对象头**、**实例数据**、**对齐填充**
2. 对象头的组成部分：**Mark Word**、**指向类的指针**、**数组长度**（可选，数组类型时才有
3. Mark Word记录了**对象**和**锁**有关的信息，在64位的JVM中，Mark Word为**64 bit**
4. 锁升级功能主要依赖于Mark Word中**锁标志位**和**是否偏向锁标志位**
5. synchronized同步锁的升级优化路径：**偏向锁**  > **轻量级锁** > **重量级锁**

> 八个字节就是8个bytes，计算机存储量的计量单位是字节，一个字节是2进制8位，八个字节等于 8*8=64 ， 即2进制64位。

![image-20230507190421335](images\image-20230507190421335.png)

#### 轻量级锁

**什么是轻量级锁？**

- “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但轻量级锁并不是用来代替重量级锁的。

如果一个对象虽然有多线程访问，但某个时间点多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化，减少传统的重量级锁使用产生的性能消耗。

> 既然多线程访问的时间是错开的（也就是没有竞争），那么为什么还要添加锁呢？
>
> 没有竞争的时候，不代表永远没有竞争，在遇到竞争的时候会锁升级，在没有竞争时候使用轻量级可以减少消耗



##### 轻量级加锁过程

- 每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word
- 而Mark Word容量非常宝贵，所以对`对象`加锁之后需要把旧的信息暂存到栈帧的一个锁记录结构，解锁之后将信息恢复到MarkWord

**这里以一个代码片段演示轻量级加锁过程**

```java
    static Object obj = new Object();
    public static void method1() {
        synchronized (obj) {
            // 同步块 A
            method2();
        }
    }
    public static void method2() {
        synchronized (obj) {
            // 同步块 B
        }
    }
```

<img src="images\image-20230507225843018.png" alt="image-20230507225843018" style="zoom:150%;" />

##### 锁升级

- 轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 

![image-20230507230824599](images\image-20230507230824599.png)



#### 重量级锁

这里演示对重量级锁的优化：自旋

![image-20230507231048048](images\image-20230507231048048.png)

自旋失败的情况

![image-20230507231117452](images\image-20230507231117452.png)



#### 偏向锁

- 偏向锁可以说是对轻量级锁的再次优化，即在没有锁竞争的时候，只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.

但是偏向锁会带来一些问题

1. 撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）
2.  访问对象的 hashCode 也会撤销偏向锁 
3. 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 重偏向会重置对象的 Thread ID 
4. 撤销偏向和重偏向都是批量进行的，以类为单位 
5. 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的 
6. 可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁



#### 锁粗化

多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁， 没必要重入多次）

这里以StringBuffer判断演示

- ```java
  new StringBuffer().append("a").append("b").append("c")
  ```

append方法是会添加锁的，理论上这里会添加三次锁

但是实际锁被粗化，只添加了一次

#### 锁消除

JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候 就会被即时编译器忽略掉所有同步操作。



























































































| 线程 1                                       | 对象 Mark Word                | 线程 2 |
| -------------------------------------------- | ----------------------------- | ------ |
| 访问同步块 A，把 Mark 复制到 线程 1 的锁记录 |                               |        |
| CAS 修改 Mark 为线程 1 锁记录 地址           |                               |        |
| 成功（加锁）                                 | 00（轻量锁）线程 1 锁记录地址 |        |
| 执行同步块 A                                 | 00（轻量锁）线程 1 锁记录地址 |        |
| 访问同步块 B，把 Mark 复制到 线程 1 的锁记录 | 00（轻量锁）线程 1 锁记录地址 |        |
| CAS 修改 Mark 为线程 1 锁记录 地址           | 00（轻量锁）线程 1 锁记录地址 |        |
| 失败（发现是自己的锁）                       | 00（轻量锁）线程 1 锁记录地址 |        |
| 锁重入                                       | 00（轻量锁）线程 1 锁记录地址 |        |
| 执行同步块 B                                 | 00（轻量锁）线程 1 锁记录地址 |        |

| 同步块 B 执行完毕 | 00（轻量锁）线程 1 锁记录地址 |                                              |
| ----------------- | ----------------------------- | -------------------------------------------- |
| 同步块 A 执行完毕 | 00（轻量锁）线程 1 锁记录地址 |                                              |
| 成功（解锁）      | 01（无锁）                    |                                              |
|                   | 01（无锁）                    | 访问同步块 A，把 Mark 复制到 线程 2 的锁记录 |
|                   | 01（无锁）                    | CAS 修改 Mark 为线程 2 锁记录 地址           |
|                   | 00（轻量锁）线程 2 锁记录地址 | 成功（加锁）                                 |

















