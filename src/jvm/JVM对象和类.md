---
createDate:2023/5/7 23:44
---



## 对象

**什么是对象？**

- **类**：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为(方法)。换言之:类是对现实生活中一类具有共同属性和行为的事物的抽象。
- **对象**：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。
  - 对象的属性: 对象所具有的各种特征，每个对象的每个特征都拥有特定的值
  - 对象的行为:对象能够执行的操作 (方法)
- **对象实例**：对象实例是一个具体的对象，它是根据某个类（Class）的定义创建出来的。



### 对象的创建方式有哪些

1. new：直接使用最常见的new关键字来创建
2. 反序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输
3. 反射：即Constructor的newInstance()
4. 克隆：即clone()方法，不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法
5. 第三方库 Objenesis



### 对象的实例化过程

在这里指代的主要是从方法区加载到对空间的一个过程

1. 判断对象对应的类是否加载、链接、初始化
2. 为对象分配内存
3. 处理并发问题
4. 初始化分配到的空间
5. 设置对象的对象头
6. 执行init方法进行初始化

**详细步骤**

1. 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程。
2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。
   - 而分配内存的方式又分为指针碰撞和空闲列表。分配的方式由堆空间决定，如是否采用分代回收以及标记整理或标记清除。
   - 指针碰撞：
   - 空闲列表：
3. 处理并发问题 
4. 初始化分配到的空间
5. 设置对象的对象头
6. 经历如上的操作之后，从JVM的角度来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始。因为还需要初始化构造函数。执行了init方法后，一个真正的对象才算完成。

> **如何查看class的init方法？**
>
> 可以使用javap工具来反编译Class文件，并查看其中的字节码指令。
>
> ```java
>  javap -c -p helloWord.class
> ```



### 对的内存布局

根据java虚拟机规范里面的描述：java对象分为三部分：对象头(Object Header), 实例数据(instance data)，对齐填充(padding)

![image-20230507234751483](images\image-20230507234751483.png)

通过上图可以看到，对象的组成主要有三部分：对象头，实例数据，以及对齐填充。

#### 对象头

<img src="images\image-20230507235023131.png" alt="image-20230507235023131" style="zoom:67%;" />

而对象头都又可以区分为二个部分

1. 第一类是用于存储对象自身的运行时数据：MarkWord。
2. 第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

> **什么是元数据指针？**
>
> 首先需要了解什么是元数据：简单来说就是加载后的class
>
> 所以元数据指针指向的是方法区的元空间的Class信息



#### 实例数据

实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，包括父类继承的和本身定义的。



#### 对齐填充

对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。





### 对象的访问定位

- JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？

![image-20230519185436629](images\image-20230519185436629.png)

通常的顺序为：栈帧 > 堆空间 > 方法区

1. 栈帧通过自己的局部变量表去堆空间寻找对应的对象实例
2. 对象实例通过类型指针去方法区获取类元信息

虚拟机规范并没有说明如何定位对象，所以主流的访问方式主要有使用句柄和直接指针两种方式

#### 句柄

1.  缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间，通过两次指针访问才能访问到堆中的对象，效率低。
2.  优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。

![image-20230519184827796](images\image-20230519184827796.png)



#### 直接指针

HotSpot采用直接指针的方式定位类的元数据信息

1.  优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据
2.  缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值

![image-20230519185103200](images\image-20230519185103200.png)





## 语法糖

​	Java语法糖是指在Java语言中添加的一些方便程序员使用的语法，它们对语言的功能没有影响，但是可以让程序更简洁和可读。通俗的说语法糖就是减少我们在编写.java的代码量，在编译为.class之后被恢复为原文。

#### 匿名内部类

​	内部类是指定义在另一个类中的类，它可以访问外部类的成员，包括私有成员。内部类分为静态内部类、成员内部类、局部内部类和匿名内部类等。编译器会将内部类转换为一个独立的类，并为其添加一个指向外部类实例的引用（如果是非静态内部类）。

#### Switch

​	switch支持String和枚举：从Java 7开始，switch语句可以使用String和枚举类型作为条件，编译器会将它们转换为整型的hashCode进行比较，并使用equals方法进行安全检查

#### 可变长参数

​	变长参数是指在定义方法时可以使用一个特殊的符号...来表示该参数可以接受任意个数和类型的实参，编译器会将它们转换为一个数组传递给方法。这样可以避免重载多个方法或者使用数组作为参数。

#### 拆装箱

​	自动装箱和拆箱：自动装箱和拆箱是指编译器在基本类型和包装类型之间自动进行转换的功能，例如int和Integer，double和Double等。这样可以避免程序员手动进行装箱和拆箱的操作，简化代码。

#### 枚举

​	枚举是一种特殊的类，它可以定义一组固定的常量，每个常量都是枚举类的一个实例。枚举可以实现接口，定义构造方法，字段和方法等。编译器会将枚举类转换为继承自java.lang.Enum的子类，并为每个常量生成一个静态实例。

#### 泛型擦除

​	泛型是一种允许在定义类、接口和方法时使用类型参数的功能，它可以增强代码的重用性和类型安全性。但是Java虚拟机并不支持泛型，编译器会通过类型擦除的方式将泛型参数替换为它们的最左边界（最顶级的父类型）类型，并移除所有的类型参数。

#### 增强for循环

​	增强for循环是指一种简化的遍历数组或集合的循环语句，它可以避免使用下标或迭代器，让代码更加简洁和清晰。Java中可以使用for关键字和冒号来定义增强for循环，它可以接受一个数组或一个实现了Iterable接口的对象作为循环对象。

#### 条件编译

​	条件编译是指根据不同的条件选择性地编译或忽略一部分代码的功能，它可以用来适应不同的平台或环境。Java中没有专门的条件编译语法，但是可以利用常量表达式和编译器的优化来实现类似的效果。

#### 断言

​	断言是指在程序中插入一些检查语句，用来验证程序的正确性或假设的成立性。如果断言失败，就会抛出一个AssertionError异常。Java中可以使用assert关键字来定义断言语句，它可以接受一个布尔表达式或者一个带有错误信息的布尔表达式。

#### 数值字面量

​	数值字面量是指在程序中直接使用数值的表示方式，而不是通过变量或常量来引用。Java中支持不同进制和类型的数值字面量，例如十进制、八进制、十六进制、二进制、浮点数、长整数等。Java 7还支持在数值字面量中使用下划线来增加可读性。

#### try-with-resources语句

​	try-with-resources语句是指一种自动管理资源的语句，它可以在try块中声明一个或多个实现了AutoCloseable接口的资源对象，并在try块结束后自动调用它们的close方法来释放资源。Java中可以使用try关键字和小括号来定义try-with-resources语句，它可以避免手动关闭资源或忘记关闭资源的问题。

#### Labda表达式

​	Lambda表达式是指一种匿名函数的表示方式，它可以将一个函数作为一个对象传递给其他方法或变量，实现函数式编程的风格。Java中可以使用箭头符号->来定义Lambda表达式，它可以接受一个或多个参数，并返回一个结果或执行一个动作。Lambda表达式可以用来实现函数式接口，即只有一个抽象方法的接口。

#### 多态



#### forEach




## 类



## 类加载

![image-20230519201514922](images\image-20230519201514922.png)

### 加载

1.  通过一个类的全限定名获取定义此类的二进制字节流

2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

3.  **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口



通过IO将类的字节码载入方法区的元空间，内部采用 C++ 的 instanceKlass 描述 java 类

它的重要 ﬁeld 有：

- _java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用
- _super 即父类
- _ﬁelds 即成员变量
- _methods 即方法
- _constants 即常量池
- _class_loader 即类加载器
- _vtable 虚方法表
- _itable 接口方法

如果这个类还有父类没有加载，先加载父类。

加载和链接可能是交替运行的

**加载class文件的方式：**

1.  从本地系统中直接加载
2.  通过网络获取，典型场景：Web Applet
3.  从zip压缩包中读取，成为日后jar、war格式的基础
4.  运行时计算生成，使用最多的是：动态代理技术
5.  由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见
6.  从加密文件中获取，典型的防Class文件被反编译的保护措施

![image-20230420111024318](images\image-20230420111024318.png)

### 链接

#### **验证**

- 验证类是否符合 JVM规范，安全性检查
- 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证

#### **准备**

为 static 变量分配空间，设置默认值

- static 变量存储于存储于 _java_mirror 末尾 ，DK 7 之前在 instanceKlass 末尾
- static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成
- 如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成
- 如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用

#### 解析

将常量池内的符号引用转换为直接引用的过程



### 初始化

**<cinic>()V 方法**

初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全

此方法不需定义，是javac编译器自动收集类中的所有**类变量**的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法

**发生的时机**
概括得说，类初始化是【懒惰的】

- main 方法所在的类，总会被首先初始化
- 首次访问这个类的静态变量或静态方法时
- 子类初始化，如果父类还没初始化，会引发
- 子类访问父类的静态变量，只会触发父类的初始化
- Class.forName
- new 会导致初始化

不会导致类初始化的情况

- 访问类的 static final 静态常量（基本类型和字符串）不会触发初始化
- 类对象.class 不会触发初始化
- 创建该类的数组不会触发初始化



## 类加载器ClassLoader

- 类加载器是一个负责加载类的抽象类对象，用于实现类加载过程中的加载这一步。
- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。
- 类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。
- JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。大部分类在具体用到的时候才会去加载。

主要的类加载器

1. **`Bootstrap ClassLoader`(启动类加载器)** ：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar` 、`resources.jar` 、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。

2. **`Extension ClassLoader`(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

3. **`AppC lassLoader`(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

4. `自定义加载器`

| Bootstrap ClassLoader（启动类加载器）     | JAVA_HOME/jre/lib     | 无法直接访问                |
| ----------------------------------------- | --------------------- | --------------------------- |
| Extension ClassLoader(拓展类加载器)       | JAVA_HOME/jre/lib/ext | 上级为Bootstrap，显示为null |
| Application ClassLoader(应用程序类加载器) | classpath             | 上级为Extension             |
| 自定义类加载器                            | 自定义                | 上级为Application           |

> 类加载器的时候涉及一种双亲委派模型



### 双亲委派模型

​	Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

- 双亲委派模型代码编写在 CLassLoader 的Class<?> loadClass(String name, *boolean* resolve)方法，简单明了。

- ```java
  protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
          synchronized (getClassLoadingLock(name)) {
              // First, check if the class has already been loaded
              Class<?> c = findLoadedClass(name);
              if (c == null) {
                  long t0 = System.nanoTime();
                  try {
                      if (parent != null) {
                          c = parent.loadClass(name, false);
                      } else {
                          c = findBootstrapClassOrNull(name);
                      }
                  } catch (ClassNotFoundException e) {
                      // ClassNotFoundException thrown if class not found
                      // from the non-null parent class loader
                  }
  
                  if (c == null) {
                      // If still not found, then invoke findClass in order
                      // to find the class.
                      long t1 = System.nanoTime();
                      c = findClass(name);
  
                      // this is the defining class loader; record the stats
                      PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                      PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                      PerfCounter.getFindClasses().increment();
                  }
              }
              if (resolve) {
                  resolveClass(c);
              }
              return c;
          }
      }
  ```

- 双亲委派模型是一种`自下而上再下`的查找加载机制

  1. 每当一个类加载器接收到加载请求时，它并不会自己尝试加载，而是将请求委托给父类加载器。

  1. 当加载器发现自己无父类的时候，尝试自己加载，如加载失败将向下依次派遣，如最终无法加载，将抛出异常。

- 双亲委派模型加载时涉及三个类主要加载器， 形成一个层级关系，但并不是使用继承/接口编写的。

  - | Bootstrap ClassLoader（启动类加载器）     | JAVA_HOME/jre/lib     | 无法直接访问                |
    | ----------------------------------------- | --------------------- | --------------------------- |
    | Extension ClassLoader(拓展类加载器)       | JAVA_HOME/jre/lib/ext | 上级为Bootstrap，显示为null |
    | Application ClassLoader(应用程序类加载器) | classpath             | 上级为Extension             |
    | 自定义类加载器                            | 自定义                | 上级为Application           |

- 加载器层级关系使用组合实现，在面向对象编程中，有一条非常经典的设计原则： **组合优于继承，多用组合少用继承。**继承会增加耦合

- 双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，不少框架都会打破双亲委派模型，如：TomCat

**双亲委派模型的好处**

1. 双亲委派模型可以增加一定的安全性，即避免核心类被替换。
2. 由于每个类加载器都会先让它的父类加载器去尝试加载，所以避免了类的重复加载。
3. 促进了Java程序的模块化。

> **缺点：**轻微影响性能。

**沙箱安全机制**

1.  自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。
2.  这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

> 沙箱安全机制主要通过：语言安全特性，字节码校验，类加载器，安全管理器来共同实现。



## 运行期优化

​	JVM运行期的优化主要是指程序在编译成字节码之后，JVM通过解释器去解释执行，再针对程序运行的资源占用等情况进行分析然后做出的一系列的优化。

#### **逃逸分析**

- 首先逃逸分析不是一种直接优化代码的手段，主要为其它的优化手段提供一个数据分析的技术。
- 逃逸分析是分析对象动态作用域，当一个对象在方法A里面被定义后，如果它被外部方法B所引用，那么它就发生了逃逸。

逃逸等级又区分为三种：

**不逃逸**

- 其他的方法和线程没有引用这个对象。

**方法逃逸**

- 作为调用参数传递到其他方法中，这种称为方法逃逸。

**线程逃逸**

- 甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸。

> 如果能证明一个对象不会逃逸到方法或线程之外，或者逃逸程度比较低，则可能为这个对象实 例采取不同程度的优化，如：栈上分配，标量替换，同步消除等



#### 栈上分配

​	JVM创建对象所需要的内存从堆空间分配的，堆空间是线程共享的，只要线程只有该对象的地址，就可以从堆空间获取该对象的数据，而堆空间是存在GC的，在GC筛选可回收，回收，回收整理都需要一定的资源。

在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所 占的比例是很大的，如果能确定对象不会出现方法逃逸，就可以在栈上分配对象，由于栈的特性，执行完毕后对象将随着栈销毁，所以不在需要GC的消耗。

但栈上分配仅仅适用于方法逃逸，不支持线程逃逸，至于原因很简单：线程私有。



#### **同步消除**

​	如果一个对象不会出现线程逃逸，也就是不会被其他的线程访问到，即读写没有竞争，那么可直接去除同步的措施，避免线程同步的资源消耗。

> **演示案列：**
>
> 这段代码中，两个方法都是同步的，但是它们没有任何实际的操作，所以同步锁是没有必要的。如果开启了同步消除，可以通过-XX:+DoEscapeAnalysis -XX:+EliminateLocks参数来运行程序，会发现耗时大大减少。这就说明JVM在运行期优化了同步锁，提高了性能。
>
> ```java
> public class SyncEliminate {
>     private static final int CIRCLE = 2000000;
> 
>     public static void main(String[] args) throws InterruptedException {
>         long start = System.currentTimeMillis();
>         SyncEliminate syncEliminate = new SyncEliminate();
>         Thread thread1 = new Thread(() -> syncEliminate.method1());
>         Thread thread2 = new Thread(() -> syncEliminate.method2());
>         thread1.start();
>         thread2.start();
>         thread1.join();
>         thread2.join();
>         long end = System.currentTimeMillis();
>         System.out.println("耗时：" + (end - start) + "ms");
>     }
> 
>     public void method1() {
>         for (int i = 0; i < CIRCLE; i++) {
>             synchronized (this) {
>                 // do nothing
>             }
>         }
>     }
> 
>     public void method2() {
>         for (int i = 0; i < CIRCLE; i++) {
>             synchronized (this) {
>                 // do nothing
>             }
>         }
>     }
> }
> ```



#### 标量替换

**什么是标量？**

- 若一个数据已经无法再分解成更小的数据来表示了，Java虚拟 机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据 就可以被称为标量。

**什么是聚合变量？**

- 相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的聚合量。

假如逃逸分析能够证明一个对象不会被方法外部 访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创 建它的若干个被这个方法使用的成员变量来代替。



#### **分层编译**



#### 公共子表达式消除

公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。



#### **方法内联**

- 把目标方法的代码 “复制” 到发起调用的方法之中，避免发生真实的方法调用。



#### 数组边界检查消除



#### **常量折叠**



#### **反射优化**

- 反射默认通过`NativeMethodAccessorImil.invoke0()`来实现的，invoke0是一个native本地方法，性能较低。

在调用次数15以后，会取消通过C++实现的代码，进而使用字节码生成。即将反射方法调用转化为正常方法调用

>  可自由设置这个阈值



## 反射

​	从栈帧的局部变量表去堆空间查找所对应的实例，再在类的实例中去方法区查找类元信息，这个指代的就是“反射可以在运行的时候获取一个类的信息”

> 直接引用，句柄



## 多态

多态与封装、继承是面向对象的三大特性。

多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。



































































