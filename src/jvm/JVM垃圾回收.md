## GC垃圾回收

> **导读**
>
> Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里 面的人却想出来。
>
> ​	为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制。Java 语言开发者比 C 语言开发者幸福的地方就在于，我们不需要手动释放对象的内存，但这种幸福也有代价的，一旦这种自动化机制出错，我们又不得不去深入理解 GC 回收机制，甚至需要对这些“自动化”的技术实施必要的监控和调节。

从计算机组成的角度来讲，所有的程序都是要驻留在内存中运行的。而内存是一 个限制因素(大小)。

除此之外，堆也有大小限制。堆要通过垃圾回收机制，来维持它的正常运作，保证对象的分配， 尽可能不造成“内存溢出”。

**什么是垃圾**

- 所谓垃圾就是内存中已经没有用的对象。 既然是”垃圾回收"，那就必须知道哪些对象是垃圾。目前的JVM主流中使用一种叫作**可达性分析的算法**来决定对象是否可以被回收。

**垃圾回收需要考虑的问题**

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

> 垃圾回收不仅仅针对堆空间，还在方法区运行，不过在方法区进行类卸载的条件非常苛刻。



### 引用计数

每个对象分配一个引用计数器，每一个对象被引用了一次，在当前的对象头上引用次数加一

每当一个引用失效，在当前的对象头上引用次数减一

当这个数子为零，代表可以被回收

**优点**：

- 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。
- 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。

- 具有区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。

**缺点**：

- 无法回收相互引用的对象，每次对象被引用时，都需要去更新计数器，有时间开销，还伴随加减运算，影响性能

> 可选使用软/弱引用来解决对象循环不能回收的问题。或者手动解除关系。



### 可达性分析

现在主流的的虚拟机都采用可达性分析算法来确定哪些内容是垃圾。

可达性分析把内存中所有的对象之间的引用关系看作一张图，从一组根对象GC Root开始往下扫描所有节点，直到扫描完毕。没有被根节点直接或间接引用的对象可以被回收。

**GC Root是一系列对象，可以是**

- System Class： 系统类Object String
- Thread： 线程活动  类栈帧局部对象
- Native Stack： 本地方法所引用的对象
- Busy Monitor： 被锁持有的对象

除了这些固定的一系列对象之外，还可根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象 “临时性” 地加入，共同构成完整GC Roots集合。

> 可达性的核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收
>
> 全局变量同静态变量不同，它不会被当作 GC Root



## 什么时候回收

不同的虚拟机实现都有不同的回收策略，不过通常可区分为两种

1. `Allocation Failure`：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC。
2. `System.gc()`：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。

> 但在实际的开发中，`System.gc()`可能被禁用，因为system.gc属于一种Full GC，会造成stw（stop then word)，即暂停所有线程，影响性能

**finalize**

但在另外一个层次来说，在一个对象被判断为可以回收的时候，并不会马上被回收。

​	每一个对象中存在一个方法`finalize`。当对象被标记为可回收后，当发生GC时，首先**会判断这个对象是否执行了finalize方法**，如果这个方法还没有被执行的话，那么就会先来执行这个方法。

​	接着在这个方法执行中，我们可以设置当前这个对象与`GC ROOTS`产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。

​	finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。

> 总结：在Object.finalize()方法用于在**对象被销毁之前的自定义处理逻辑**可以编写代码来延长对象的生命周期 
>
> 但在实际上，不建议使用finalize，如需要关闭资源使用try-finally。



## 方法区的GC

方法区相比于堆空间的每一次回收70%-99%的空间来说，方法区的回收效率非常低。

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于 “不再被使用的类” 的条件就比较苛刻了。需要同时满足下面三个条件

#### 判断类是否可回收

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。

但就算这样，也仅仅是允许可回收，而不是立即回收

#### 其他区域的回收

​	程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。在栈上，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。*尽管在运行期会由即时编译器进行一些优化*

因此这几个区域的内存分配和回收都具备确定性，当方法结束后或者线程结束后，内存就被回收了。

> 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



## 四种引用

​	在以前的JDK版本中，只用引用和未引用两种状态，对于描述一些 “食之无味，弃之可惜” 的对象就显得无能为力。也就是无法描述在内存空间充足的时候保留，在内存紧候抛弃掉的对象。

​	所以`JDK1.2`以后JVM提供了不同的对象引用，这样可以让程序员通过代码的方式决定对象的生命周期，同时还有助于JVM进行垃圾回收，比如强引用不被回收，弱引用则扫描即回收。

1. **强引用**(StronglyReference) 

   普通的 `User user = new User()`即为强引用，它永远不会被回收，jvm宁愿抛出**O**ut**O**f**M**emory也不会回收，所以强引用是造成内存泄漏的主要原因之一。

2. **软引用**(SoftReference)  

   如对象具有软引用，它在内存充足时不会回收， 内存不够时才回收。软引用适合做缓存，在内存足够时，直接通过软引用取值，无需从真实来源中查询数据，可以显著地提升网站性能。

3. **弱引用**(Weak Reference) 

   Full GC扫描即回收，不论内存是否充足。

4. **虚引用**(Phantom Reference) 

   对象退化到虚引用即被回收，是最弱的引用，甚至无法通过它来获取它所指向的对象，必须配合引用队列，主要用于跟踪对象回收。

5. **终结器引用**

​		用于实现对象的finalize方法。

> 除强引用外，开发者可以在`java.lang.ref`中找到对应引用的类来包装自己的对象
>
> 软引用，弱引用可以配合引用队列来释放软引用自身



## 垃圾回收算法

### 标记-清除

1. 先使用可达性分析从根对象开始扫描，如没有被直接引用或间接引用，则先标记

2. 将先前标记的空间释放，但释放并不会直接清零，而是将地址放入空闲地址列表，下次分配对象从列表查找空闲地址

缺点：

- 因为并没有实际清零，容易产生内存碎片。因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。意思是，之前的空闲列表的每一个空闲位置，不能放入现在过大的对象。所以在需要分配对象的时候不得不提前触发另一次垃圾收集动作

- 并且效率较低，标记和清除两个动作都需要遍历所有的对象，并且随着需回收的对象增长而降低效率。

> 后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进。
>
> 这种的特性适用与老年代，因为老年代GC间隔长，且多数对象存活，内存碎片较少。



### 标记-整理

标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法，最主要的区别是不会产生内存碎片。

1. 从根对象通过可达性分析标记垃圾。

2. 将被标记的地址向右重排序，使其有序无空闲，清除左侧不需要的对象。

3. 将先前标记的空间释放清零。

标记-整理不会产生内存碎片，由于需要将内存地址重排序，需要改变所属对象的地址，比标记-清除多出一步操作，并且需要暂停用户进程，即Stop The World，因此效率相对低。



### 标记-复制

复制的核心观点是将原有的内存空间分为两块，每次只使用其中一块

1. 将内存区域分成两部分，每次操作其中一个
2. 在垃圾回收时，将正在使用 的内存中的存活对象复制到 未使用的内存块中
3. 清除正在使用的内存块中 的所有对象，交换两个内存的角色，完成垃圾回收
4. 周而复始

优点：复制并不会产生内存碎片，在垃圾对象越多的情况，效率越高，因为需要移动的对象变少。

缺点：但需要双倍空间，并且同时只能使用一半的空间，不适用于每一次垃圾比较少的场景，典型的空间换时间。

> 根据分代回收思想，适用于新生代。



## GC分类

我们都知道，根据垃圾收集器的不同，但对堆空间的回收策略基本为分代回收，所以GC根据分代也拥有不同的类别。

1. 部分收集：新生代收集（Minor GC/Young GC）、老年代收集（Major GC/Old GC）、混合收集（Mixed GC）
2. 整堆收集：整堆收集（Full GC）

#### Minor GC

- 指目标只是新生代的垃圾收集。

#### Major GC

- 指目标只是老年代的垃圾收集

#### Full GC

- 收集整个Java堆和方法区的垃圾收集

> 可以说在堆空间划分了不同的区域之后，才因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。



## 分代回收

![image-20230409134758721](images\image-20230409134758721.png)

Java 虚拟机根据对象存活的周期不同将堆空间进行区分，**分代的唯一理由就是优化GC性能**，如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。



### 新生代	

​	对象通常首先分配在新生代的伊甸园区域，新生代的类对象的创建和消亡都非常迅速，常规应用进行一次垃圾收集一般可以回收70%~95% 的空间，回收效率很高。

新生代又区分为一个伊甸园和二个幸存者区，它们的默认比列为8:1:1，划分2块Survivor原因为采用复制算法效率较高。

#### 伊甸园

绝大多数对象首先分配在伊甸园区域，当Eden区第一次没有足够的空间进行分配时，虚拟机将发起一次Minor GC

1. 先将Eden区域有用的对象进行标记
2. 将标记的对象移动到Survivor0区域，并将Survivor0 和Survivor1进行一次交换，每一次交换存活下来的对象年龄加一
3. 直接清除所有的Eden区域

#### 幸存区 From

新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to

- 最大阈值为15的时候会晋升到老年代，同时也是默认阈值。

**晋升默认阈值为什么是15？**

- 这是因为对象头的MarkWord的空间非常宝贵，容量上线是15，所以在设置阈值的时候只能小于15。


#### 幸存区 TO

幸存区使用标记复制算法

对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被幸存区容纳的话，将被移动到幸存区空间中

> **新生代为什么再次划分？**
>
> 区分二个幸存者区域，在伊甸园需要的对象被移动至幸存者区域
>
> 由于伊甸园的有用对象被移动幸存者区域，伊甸园可直接清空，而不需要标记后整理，也不会产生一个内存碎片
>
> 二块幸存者区域可以使用标记复制清除算法，效率高，缺点是需要双倍空间



### 老年代

​	在新生代中经历了多次GC后仍然存活下来的对象会进入老年代中，也就是当对象寿命超过阈值时，这个最大寿命是15（4bit），老年代的内存大小一般比新生代大，能存放更多的对象。

在一些特殊的情况下，一些大对象在新生代内存不足时，会被直接分配至老年代。

老年代对象的生命周期较长，GC回收频率相对低，因为更多，所以回收效率相对慢，通常采用标记-压缩算法进行清除。

当老年代空间不足，会先尝试触发 Minor GC，如果之后空间仍不足，那么触发 Full GC，STW的时间更长，所以一般使用禁止`System.gc()`，因为`System.gc()`是一个 Full GC。



### 新生代和老年代的GC Log 分析

新生代和老年代所打印的日志是有区别的：

1. 新生代 GC：这一区域的 GC 叫作 Minor GC。因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。
2. 老年代 GC：发生在这一区域的 GC 也叫作Full GC 或者 Major GC 。当出现了 Major GC，经常会伴随至少一次的 Minor GC。



### 新生代晋升的规则

**Eden区满时**

- 进行Minor GC，当Eden和一个Survivor区中依然存活的对象无法放入到Survivor中，则通过分配担保机制提前转移到老年代中。 

**若对象体积太大**

- 新生代无法容纳这个对象，-XX:PretenureSizeThreshold即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对Serial及ParNew两款收集器有效。

**长期存活的对象将进入老年代**

- 虚拟机对每个对象定义了一个对象年龄（Age）计数器。当年龄增加到一定的临界值时，就会晋升到老年代中，该临界值由参数：-XX:MaxTenuringThreshold来设置。
- 如果对象在Eden出生并在第一次发生MinorGC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor中，并且设Age=1；以后每经历一次Minor GC，该对象还存活的话Age=Age+1。

**动态对象年龄判定**

- 虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。



### 分代内存比列

在 Java 中，堆被划分成两个不同的区域：`新生代` ( Young )、`老年代` ( Old )。

新生代 ( Young ) 又被划分为三个区域：`Eden`、`From Survivor`、`To Survivor`。

- 新生代的默认大小为堆空间的1/3
  - 伊甸园默认大小为新生代的8/10
  - 幸存者区域0默认大小为新生代的1/10
  - 幸存者区域1默认大小为新生代的1/10
- 老年代的默认大小为堆空间的2/3

![image-20230508143036706](images\image-20230508143036706.png)

>  新生代和老年代为 1:2
>
>  新生代为8:1:1



### 堆空间常见参数

**含义** 								**参数**

堆初始大小					 -Xms

堆最大大小					 -Xmx 或 -XX:MaxHeapSize=size 

新生代大小 					-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 

幸存区比例（动态） 	-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 

幸存区比例					 -XX:SurvivorRatio=ratio 

晋升阈值 						-XX:MaxTenuringThreshold=threshold 

晋升详情 						-XX:+PrintTenuringDistribution

GC详情	 					  -XX:+PrintGCDetails -verbose:gc 

FullGC 前 MinorGC	   -XX:+ScavengeBeforeFullGC



## 空间担保分配

​	空间担保分配指的是在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。也就是说在Minor GC的时候需要确认这一次的Minor GC是否安全。

​	如果不成立，则虚拟机会先查看`XX：HandlePromotionFailure`参数的设置值是否允许担保失败，如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的，如果小于，或者`-XX： HandlePromotionFailure`设置不允许冒险，那这时就要改为进行一次Full GC。

------

通常来说新生代的回收效率达到了70%以上，但也不排除极端的情况。

如果伊甸园回收的对象非常少，也就是默认的8:1:1容量，在8容量上只回收了1容量对象，剩下的7容量对象无法放入容量1中。

由于老年代的容量为总空间   的3/2，所以在幸存者区无法容纳的时候只能放入老年代的空间，其中涉及新生代晋升规则。

但前提是老年代的剩余空间 能容纳新生代所有的存活的对象。

>  众所周知Full GC会对整个堆空间进行回收，并且伴随着stw，影响性能，所以通常的情况下应该设置允许担保失败。



## HotSpot的GC算法细节实现

#### 根节点枚举

- 可达性分析是通过一系列的GC Root对象来标记对象是否被使用，尽管如此，但在大量的区域位置中遍历寻找显然是不现实的，所以寻找GC Root可不容易。

所有的收集器在根节点枚举的时候都需要暂停用户线程，如标记-整理需要发生 `stop the word`。

**为什么需要stw？**

- 如同数据库全局锁一样，根节点枚举需要在一个一致性的环境下才能准确查找，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，这样的情况下查找显然无法正确。

由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。



#### 安全点和安全区域

在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举。

但导致OopMap内容变化的指令非常多，不可能在每时每刻纠正变化，而安全点就是规定了在哪一些时刻纠正变化。

**哪一时刻才能被作为安全点？**

​	Safe Point的选择很重要，**如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题**。大部分指令的执行时间都非常短暂，通常会根据“**是否具有让程序长时间执行的特征**”为标准。比如：选择一些执行时间较长的指令作为Safe Point，**如方法调用、循环跳转和异常跳转等**。

**线程该如何在安全点停止？**

1. 抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
2. 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候**主动轮询**这个标志，如果中断标志为真，则将自己进行中断挂起。

**安全区域（Safe Region）**

1.  Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？
2.  例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。
3.  **安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的**。我们也可以把Safe Region看做是被扩展了的Safepoint。

**安全区域的执行流程**

1.  当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程
2.  当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；



#### 记忆集与卡表

**什么是跨代引用**

按照分代思想，一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。

但这样会带来一个问题，如果老年代的对象A需要新生代的对象B提供数据呢？这样如何确定它们之间是依赖的，而不是无用的对象？

所以为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。这样降低了minorGC的效率。

**如何解决**

- 垃圾收集器在新生代建立记忆集的数据结构，这样可以避免把整个老年代加入GC Roots的扫描范围。

**什么是记忆集**

- 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。简单来说，记忆集就是用来记录跨代引用的表。

**卡表**

- 上述所说记忆集用于避免扫描整个老年代空间，而卡表则是记忆集的具体实现方式。

**关于其他记忆集的实现方式**

1. 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 
2. 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 
3. 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

> 但实际上跨代引用是极少的，并且不同的垃圾收集器有不同的实现方式
> G1垃圾收集器使用了基于哈希表的记忆集，可以记录每个Region有哪些Region指向它，并且能知道具体是哪块区域存在指针指向，这样提高了效率，但增加了内存占用量



## 垃圾回收器

### 相关概论

JVM中常用的垃圾回收器包括

1. 串行(Serial)：只有一个线程执行垃圾回收
2. 并行(Parallel)：允许多个线程并行执行垃圾回收
3. 并发(CMS)：并发指的是GC线程执行垃圾回收的同时可以有业务线程执行业务逻辑
4. G1(收集器)：将原有JVM物理内存连续的分代逻辑打散为逻辑上内存连续的分代区域



#### **串行和并行以及并发**

**串行**

- 串行的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。
- 串行的优点是实现简单，效率高，不需要多线程交互，缺点是会造成较长的停顿时间，无法利用多处理器的优势，只能用于小型应用

**并行**

- 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收。
- GC并行的优点是可以利用多核CPU的优势，大幅降低GC暂停时间，提升吞吐量；缺点是会占用更多的系统资源，可能影响应用程序的性能，对响应时间有要求的应用不太适合。

**并发**

- 并发可以与应用线程同时执行
- GC并发的优点是可以与应用程序线程同时执行，减少单次GC的停顿时间，降低业务系统的延迟；缺点是会增加垃圾回收的总时间和开销，需要更多的内存空间和处理器资源，可能影响吞吐量。



#### **评估GC的性能指标**

1.  吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 \+ 内存回收的时间）
2.  垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
3.  暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
4.  收集频率：相对于应用程序的执行，收集操作发生的频率。
5.  内存占用：Java堆区所占的内存大小。
6.  快速：一个对象从诞生到被回收所经历的时间。



### 串行

![image-20230409163317969](images\image-20230409163317969.png)

单线程

新生代  复制 

老年代  标记整理



### 吞吐量优先

![image-20230409145519848](images\image-20230409144927055.png)

并行垃圾回收器 (Parallel Garbage Collector)



### 响应时间优先

![image-20230409145519848](images\image-20230409145519848.png)

并发标记扫描垃圾回收器 (CMS Garbage Collector)

1. 初始标记，标记root 
2. 并发标记，沿着root找出剩余
3. 重新标记, 因为并发标记后地址可能改变，需要重新标记
4. 清理



### G1 

![image-20230409145519848](images\image-20230409164157776.png)

- 同时注重吞吐量和低延迟（响应时间）
- 超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域
- 整体上是标记-整理算法，两个区域之间是复制算法

Young Collection：对新生代垃圾收集
Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。
Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。



#### JDK 8u20 字符串去重

- 将所有新分配的字符串（底层是 char[] ）放入一个队列

- 当新生代回收时，G1 并发检查是否有重复的字符串

- 如果字符串的值一样，就让他们引用同一个字符串对象

- 注意，其与 String.intern() 的区别

  - String.intern() 关注的是字符串对象

  - 字符串去重关注的是 char[]

  - 在 JVM 内部，使用了不同的字符串标

优点与缺点

- 节省了大量内存
- 新生代回收时间略微增加，导致略微多占用 CPU

```java
-XX:+UseStringDeduplication
```



#### JDK 8u40 并发标记类卸载

在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类

条件比较苛刻，但在框架使用了自定义加载器还是可以实现的

```java
-XX:CLassUnloadingWithConcurrentMark //默认启用
```



#### JDK 8u60 回收巨型对象

- 一个对象大于region的一半时，就称为巨型对象
- G1不会对巨型对象进行拷贝，因为体量大拷贝效率低
- 回收时被优先考虑
- G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉



#### JDK 9 并发标记起始时间的调整

- 并发标记必须在堆空间占满前完成，否则退化为 FulGC

- JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent

- JDK 9 可以动态调整

  - 进行数据采样并动态调整

  - 总会添加一个安全的空挡空间

  - ```java
    -XX:InitiatingHeapOccupancyPercent 用来设置初始值
    ```

除此之外JDK 9 拥有更高效的回收,宣传250+增强 180+bug修复，详情https://docs.oracle.com/en/java/javase/12/gctuning

​                      

### CMS

​	CMS收集器（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”算法实现。它的运作过程分为四个步骤，包括：初始标记、并发标记、重新标记和并发清除。它主要用于老年代的垃圾回收，与新生代的收集器配合工作。



### CMS和G1

CMS和G1垃圾收集器都是针对老年代的收集器，它们的主要区别和优缺点如下

#### CMS

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现。它的优点是：

- 支持并发收集，低停顿，因为CMS可以控制将耗时的两个stop-the-world操作保持与用户线程恰当的时机并发执行，并且能保证在短时间执行完成，这样就达到了近似并发的目的。

它的缺点是：

- 对CPU资源非常敏感，在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。
- 无法处理浮动垃圾，在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理时才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’，一旦出现此错误时便会切换到SerialOld收集方式。
- 清理后会产生大量的内存碎片，当有不足以提供整块连续的空间给新对象/晋升为老年代对象时又会触发FullGC。
- 在JDK 9之后被废除。

#### G1

​	G1（Garbage First）收集器是一种面向服务端应用的收集器，基于“标记整理”实现，将堆内存划分成一个个Region（1MB~32MB），从而避免很多GC操作在整个Java堆或者整个年轻代进行。它的主要特点在于达到可控的停顿时间，用户可以指定收集操作在多长时间内完成，即G1提供了接近实时的收集特性。它的优点是：

- 并行与并发：G1充分发挥多核性能，使用多CPU来缩短Stop-The-world的时间。
- 分代收集：G1能够自己管理不同分代内已创建对象和新对象的收集。
- 空间整合：G1从整体上来看是基于‘标记-整理’算法实现，从局部（相关的两块Region）上来看是基于‘复制’算法实现，这两种算法都不会产生内存空间碎片。
- 可预测的停顿：它可以自定义停顿时间模型，可以指定一段时间内消耗在垃圾回收商的时间不大于预期设定值。

它的缺点是：

- 内存占用较高：G1需要维护多种数据结构来管理Region之间的引用关系，如Remembered Set和OopMap等，这些数据结构会消耗一定比例（10%-20%）的Java堆空间。
- 并发阶段可能会降低吞吐量：在并发标记和筛选回收阶段，G1需要与用户线程竞争CPU资源，如果CPU资源不足或者用户线程优先级较高，可能会导致G1无法及时完成工作而触发FullGC。



### ZGC

​	ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器²³。它是由Oracle公司研发的，并于2018年提交给OpenJDK，成为OpenJDK11中的一个实验性质的特性。它可以在任意堆内存大小下都可以把垃圾收集的停顿时间限制在10ms以内。



## 调优

调优的目的：减少GC的频率，降低内存溢出风险、提高运行效率。



### 调优策略

1. 合理分配堆空间的内存
2. 优化程序的逻辑：资源复用等
3. 减少在堆的空间分配
4. 防止内存泄漏

​                                                                                                                                                                                                                                                                                                     

### Jvm垃圾回收调优

使用命令查看虚拟机运行参数

```java
-XX:+PrintFlagsFinal -version / findstr "GC"
```

调优可以从内存、锁竞争、cpu占用、io

应该根据项目类型出发，是低延时还是高吞吐，从而选择合适的回收器



### 新生代调优

调整新生代大小

#### 新生代幸存区调优

幸存区容量大于等于【当前活跃对象+需要晋升的对象】

 设置合适晋升阈值，让长时间存活的对象尽快晋升



#### 案例

案例1：Full GC 和 Minor GC 频繁
案例2：请求高峰期发生 Full GC，单次暂停时间特别长（CMS）
案例3：老年代充裕情况下，发生 Full GC（jdk1.7）



