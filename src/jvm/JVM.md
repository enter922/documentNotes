### 元空间会产生内存溢出么？在什么情况下会产生内存溢出？

首先要了解什么是元空间，元空间是方法区的一个具体实现，在以前的版本中使用永久代代替。

它与持久代最大区别在于，Metaspace脱离了虚拟机内存中，使用本地内存。

元空间存放了以下信息：

- 虚拟机加载的类信息
- 常量池
- 静态变量
- 即时编译后的代码

**出现问题原因**

错误的主要原因, 是加载到内存中的 class 数量太多或者体积太大。

**解决办法**

增加 Metaspace 的大小

```shell
-XX:MaxMetaspaceSize=512m
```



### 解释 Java 堆空间及 GC？

首先一个类通过类加载器加载到方法区之中，创建对象之后会分配在堆空间。

而堆的空间是一定的，因此就需要回收不再需要使用的对象，以便于分配新的使用对象，这个回收就是GC。

堆空间的垃圾回收使用可达性分析，标记算法，以及分代。



### 说一下 JVM 的主要组成部分及其作用？

M包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

**类加载器**：通过io/双亲委派模式将类加载到方法区

**方法区**：方法区是一个概念，具体的实现是元空间，它脱离了虚拟机内存在本地内存中。在以前的jvm版本中，它的具体时间是永久代，并且存在于JVM的虚拟内存。线程共有，存在溢出。

**虚拟机栈**：每一个方法的执行都在这里，一个方法对应着一个栈帧，只能有一个活动栈帧。线程私有，存在溢出。

**本地方法栈**：与虚拟机栈类似，不同的是，它执行的是一些Java不便实现的代码，通常是c++。

**即时编译**：对一些热点代码作出优化。

**堆**：对象创建的实力将被分配到推空间，堆空间也是垃圾回收器主要工作的地方。存在溢出，线程共有。

**程序计数器:** 用于记录当前执行的指令。在多线程的情况下也确保位置。不存在溢出，线程私有。



### Java 中堆和栈有什么区别？

JVM 中堆和栈属于不同的内存区域，使用目的也不同，但都存在溢出。

- **本地方法栈**：和数据结构栈类似，执行的方法将被压入栈。栈常用于保存方法帧和局部变量，栈通常都比堆小，也不会在多个线程之间共享。
- **堆空间**：而对象总是在堆上分配，堆被整个 JVM 的所有线程共享，所以空间占用也更大。

*解析：先讲解一下什么是堆和栈，再讲解相同点和不同点*



###  JVM 内存模型中，为什么要区分新生代和年老代，对于新生代，为什么又要区分eden 区survial区?

**这个所说的应该是分代垃圾回收相关的知识点**，首先这个分代区分是对堆空间区分，因为垃圾回收主要就工作在堆空间上



区分新生代还老年代还是比较好理解的，是又有对象有不同的生存时间，有的对象需要存活的时间就可能短一些，有的的可能长一些。

如果所以对象放到一个代中，不利于垃圾回收的管理，可以理解成为，将一个学校不同的年级放到一个教室，这样肯定是不行的。

所以在JVM内存模型中，区分为新生代和老年代。

- 对象首先分配在新生代，新生代的对象一般都是存活时间短，80%的对象在新生代从分配到回收。
- 而老年代一般是存活久一些，之前说了对象首先分配到新生代，那么老年代的对象是如何来的？这个就需要说一下新生代的划分

新生代区分为：一个伊甸园，二个幸存者区，默认比列为`8:1:1`

对象首先分配在新生代的伊甸园区，在空间不足的时候会发起一次MinGC，但伊甸园肯定还有正在使用，不能被回收的对象。那么这个对象将会被移动至幸存者区，每一次没有被回收后年龄加一，阈值达到15之后晋升到老年代。

至于为什么要区分二快幸存者区域还需要从垃圾回收算法说起

标记-清除

- 直接将需要回收的对象放入一个表中，标记为已回收（实际未回收），下一个需要分配的从表中查找地址，由于未整理内存，所以速度快。但也可能存在内存碎片，即2个对象中间，不能放入更大的对象。

标记-压缩

- 标记-压缩也可以称呼为标记-整理，和标记-清除类似，但回整理回收后的内存空间，由于需要整理，所以速度相对来说较慢，但不会存在内存碎片。

标记-替换

- 将对象回收之后，与另一块内存区域做一个替换，速度快，但需要占用双倍空间，

而幸存者区域使用这个回收算法，即速度快，也不会发生内存碎片，缺点是需要双倍空间。

至于三个回收算法的标记前缀指的是，判断哪一些对象可以被回收，后面的字段指的是具体怎么回收的。

之前说到为什么分代的原因有对象存活时间不同，其实区别还有一个算法不同。

新生代使用的minGC，而年代使用的Full GC。

MinGC性能更好，而FullGC性能更差，因为FullGC会有一个word then stop，会停止所有线程。

但通常在FUll GC回收之前会发起一个Min回收。





























































