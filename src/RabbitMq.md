---
createDate:2023/5/11 18:49
---

## 什么是RabbitMQ

- RabbitMQ主要包含的功能有：**异步处理、流量削峰、解耦**

RabbitMQ是Erlang 语言开发的一种基于AMQP协议的开源**消息队列**系统，用于在应用程序之间异步地传递数据。RabbitMQ的优点包括可靠性、高并发、灵活的路由和集群部署。RabbitMQ的使用场景包括解耦、异步处理、流量削峰等。RabbitMQ的工作原理涉及**生产者、消费者**、代理、消息、队列、交换器、绑定和路由键等概念。

**什么是消息队列？**

- 消息队列(Message Queue)简称MQ，也称：消息中间件，除Rabbit其他的还有：Kafka、RocketMQ、ActiveMQ。

**什么是AMQP？**

- 应用间消息通信的一种协议，与语言和平台无关。



### RabbitMQ有什么作用

首先盘点在使用Dubbo会遇到的问题，而RabbitMQ对此有比较好的解决方案。

1. 耦合度高：每次加入新的请求，需要修改原有的代码。
2. 性能下载：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。
3. 资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源，属于同步调用。
4. 级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障。



#### 异步处理

**为什么需要异步处理？**

​	在使用Dubbo的远程调用的时候会遇到一个问题，由于Dubbo是同步阻塞的，在远程调用的时候，该方法需要需要原地等待直至响应返回结果。在不需要立即使用返回数据的时候，这个等待就造成了不必要的消耗。

RabbitMQ的异步处理就可以很高的解决这个问题。

**概念举例：**

​	拨打电话是同步通信，不能一次性连接多个，而发微信是异步通信，一次性可以给多人发送，且对方不需要立即回复。

在业务上比如：短信，发送邮件，使用Rabbit就不需要等待结果，可以立即返回处理其他任务。

> 但同步调用时效性较强，可以立即得到结果，多数情况就需要这样的结果

**业务举例：**

- 异步调用常见实现就是事件驱动模式

在用户支付成功后，直接生成订单id等信息返回。由Rabbit去进行订单服务、仓储服务、短信服务。



**同步VS异步**

同步调用的优点：时效性较强，可以立即得到结果

同步调用的问题：耦合度高性能和吞吐能力下降有额外的资源消耗有级联失败问题

异步通信的优点：耦合度低吞吐量提升故障隔离流量削峰

异步通信的缺点：依赖于Broker的可靠性、安全性、吞吐能力架构复杂了，业务没有明显的流程线，不好追踪管理

> 但使用Rabbit相同的会带来部分问题。



#### 流量削峰

流量削峰是Rabbit一个重要的功能。流量削峰是指在系统面临高并发的情况下，通过一些技术手段，将流量分散到不同的时间段或者不同的节点，避免系统因为流量超过承载能力而崩溃。



那么该如何流量限制呢，这样就对应不同的流量削峰算法，常用方法有：

- 消息队列：将请求放入消息队列中，让系统按照一定的速率消费请求，缓解瞬时的压力。
- 漏桶算法：将请求放入一个有固定出口速率的漏桶中，当漏桶满了时，拒绝新的请求。
- 令牌桶算法：将请求放入一个有固定容量和恒定入口速率的令牌桶中，当令牌桶空了时，拒绝新的请求。
- 滑动窗口算法：使用Redis的zset数据结构，记录每个请求的时间戳，根据时间窗口的大小，统计窗口内的请求数量，当请求数量超过阈值时，拒绝新的请求。
- Lua脚本：使用Redis支持的Lua脚本，实现复杂的令牌桶或漏桶算法，保证原子性和性能。
- 网关层限流：使用Nginx、Openresty、Kong、Zuul、Spring Cloud Gateway等网关组件，在网关层对请求进行限流，过滤无效或恶意的请求。

流量削峰的目的是让系统牺牲部分请求，使整个处理请求更加平缓，节省服务器资源，提高用户体验和系统稳定性。



#### 解耦

解耦是指降低系统之间的依赖关系，让消息的生产者和消费者不需要直接调用接口，而是通过消息队列来传递数

> 消息队列的特征：
>
> * 利用异步的特性,提高服务器的运行效率,减少因为远程调用出现的线程等待\阻塞时间
> * 削峰填谷:在并发峰值超过当前系统处理能力时,我们将没处理的信息保存在消息队列中,在后面出现的较闲的时间中去处理,直到所有数据依次处理完成,能够防止在并发峰值时短时间大量请求而导致的系统不稳定
> * 消息队列的延时:因为是异步执行,请求的发起者并不知道消息何时能处理完,如果业务不能接受这种延迟,就不要使用消息队列



## Rabbit特性

1.可靠性（Reliability） RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。

2.灵活的路由（Flexible Routing） 在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。

3.消息集群（Clustering） 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker

4.高可用（Highly Available Queues） 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。

5.多种协议（Multi-protocol） RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。

6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。

7.管理界面（Management UI） RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。

8.跟踪机制（Tracing） 如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。

9.插件机制（Plugin System） RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。



### 安装

推荐使用docker安装

```sh
docker pull rabbitmq:3-management

docker run \
 -e RABBITMQ_DEFAULT_USER=root \
 -e RABBITMQ_DEFAULT_PASS=123112 \
 --name mq \
 --hostname mq1 \
 -p 15672:15672 \
 -p 5672:5672 \
 -d \
 rabbitmq:3-management
```

>  win需要配置Erlang环境



## 事务处理

当接收消息队列中信息的模块运行发生异常时，怎么完成事务的回滚？

在处理消息队列异常时，设置一个"死信队列"，将无法处理的异常信息发送到这个队列中。但死信队列没有任何处理者，通常情况下会有专人周期性的处理死信队列的消息。





## Rabbit的组成

RabbitMQ的组成，它是有这几部分：

- Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。
- Exchange：消息队列交换机。**按一定的规则将消息路由转发到某个队列**。
- Queue：消息队列，存储消息的队列。
- Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。
- Consumer：消息消费者。消费队列中存储的消息。

**工作步骤**

1. 消息生产者连接到RabbitMQ Broker，创建connection，开启channel。
2. 生产者声明交换机类型、名称、是否持久化等。
3. 生产者发送消息，并指定消息是否持久化等属性和routing key。
4. exchange收到消息之后，**根据routing key路由到跟当前交换机绑定的相匹配的队列**里面。
5. 消费者监听接收到消息之后开始业务处理。



## 工作模式

RabbitMQ的工作模式有六种：simple简单模式、work工作模式、publish/subscribe 发布/订阅模式、routing路由模式、topic 主题模式、RPC模式。

RabbitMq官网模式演示https://www.rabbitmq.com/getstarted.html

#### **simple 简单模式**

​	一个生产者发送到一个队列，然后被一个消费者消费。

**缺点：**simple单个消费者的处理能力可能有限，如果消费者处理速度慢于生产者发送速度，队列中的消息会堆积，占用大量的内存和磁盘空间，这个时候就需要多个消费者，即Work工作模式。

> 在不拥有交换机的模式下：simple简单模式仍然有一个默认的交换机：default AMQP交换机



#### **Work 工作队列模式**

​	一个生产者通过默认交换机发送消息到一个队列中，多个消费者可以监听同一个队列。每一个消费平均分配，实现负载均衡，每个消费者获取到的消息唯一，而不是共同消费。

**多个消费者的情况下有不同的消费策略**

1. 轮询分发：a和b各一半
2. 公平分发：根据能力不同发送多或少

**应用场景：**商城用户订单

> Work 工作队列模式仍然有一个默认的交换机：default AMQP交换机
>
> 相比于简单模式，工作队列模式添加了多个消费者



#### **publish/subscribe发布订阅模式**

​	一个生产者通过一个交换机，发送消息个给多个队列，然后被多个消费者消费。

相比于工作队列模式，增加了一个交换机，多个队列。后续的模式都在此基础进行改进。

- 由交换机分配到将不同的队列。
- 不同的队列可以存放不同的任务。

**应用场景：**用户注册后需要进行短信服务 、邮件服务，这样可以放到不同的队列。

**缺点：**如果消费者的数量过多，会导致交换机的广播压力过大，影响性能。

> exchange负责消息路由，而不是存储，路由失败则消息丢失
>
> 相比于工作队列模式模式，发布订阅模式添加一个交换机和多个队列



#### **routing 路由模式**

 生产者发送的消息，根据交换机定义的路由规则，决定往哪个队列发送。

> 相比发布订阅模式，路由模式可以选择性的发送到不同的队列



#### **topic 主题模式**

为生产者，一个交换机，根据模糊匹配路由规则，多个队列，多个消费者。

> 相比于路由模式增加了模糊匹配，从而发送到不同的队列



**RPC模式**为客户端 Client 先发送消息到消息队列，远程服务端 Server 获取消息，然后再写入另一个消息队列，向原始客户端 Client 响应消息处理结果。

> ​	在SpringAMQP的发送方法中，接收消息的类型是Object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。
>
> ​	Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。如果要修改只需要定义一个MessageConverter 类型的Bean即可。推荐用JSON方式序列化



## 路由模式

RabbitMQ基于交换机，提供四种不同的路由模式

RabbitMQ的路由模式有以下几种：

1. Direct：直接路由，根据消息的路由键和队列的绑定键完全匹配，将消息发送到对应的队列。
2. Fanout：扇形路由，忽略消息的路由键，将消息广播到所有绑定到交换机的队列。
3. Topic：主题路由，根据消息的路由键和队列的绑定键进行模糊匹配，支持通配符 * 和 #，将消息发送到匹配的队列。
4. Headers：头部路由，根据消息的头部信息和队列的绑定信息进行匹配，支持 x-match = any 或 all，将消息发送到匹配的队列。

RabbitMQ的路由模式可以根据不同的业务场景和性能要求进行选择和配置，以实现灵活的消息分发。





## 面试题

### 你们为什么选择了RabbitMQ而不是其它的MQ？

### RabbitMQ何确保消息的不丢失？

### RabbitMQ如何避免消息堆积？

### RabbitMQ如何保证消息的有序性？

### 如何防止MQ消息被重复消费？

### 如何保证RabbitMQ的高可用？

### 使用MQ可以解决那些问题？

























   
